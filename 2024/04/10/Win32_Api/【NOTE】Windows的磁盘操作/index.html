

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Insomniac">
  <meta name="keywords" content="keywords">
  
    <meta name="description" content="一、基本概念首先说明一点，本文中使用的不是cmd命令行，基于以下几点原因： 1．在C&#x2F;C++中调用系统命令会存在处理的种种不方便，需要大量额外的代码去分析命令执行结果。 2．windows命令行远不如linux的shell来的强大。 3．效率。 当然，如果不考虑编码，仅作为系统下一种应用工具的话，DiskPart是既安全又便利的选择。   我们先来看几个主要的使用频繁的函数。 在wind">
<meta property="og:type" content="article">
<meta property="og:title" content="【NOTE】Windows的磁盘操作">
<meta property="og:url" content="https://zytpca.github.io/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Insomnia_">
<meta property="og:description" content="一、基本概念首先说明一点，本文中使用的不是cmd命令行，基于以下几点原因： 1．在C&#x2F;C++中调用系统命令会存在处理的种种不方便，需要大量额外的代码去分析命令执行结果。 2．windows命令行远不如linux的shell来的强大。 3．效率。 当然，如果不考虑编码，仅作为系统下一种应用工具的话，DiskPart是既安全又便利的选择。   我们先来看几个主要的使用频繁的函数。 在wind">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zytpca.github.io/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/image-0.png">
<meta property="og:image" content="https://zytpca.github.io/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/image-1.png">
<meta property="article:published_time" content="2024-04-10T03:28:28.000Z">
<meta property="article:modified_time" content="2025-04-24T08:11:02.764Z">
<meta property="article:author" content="Insomniac">
<meta property="article:tag" content="keywords">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zytpca.github.io/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/image-0.png">
  
  
  
  <title>【NOTE】Windows的磁盘操作 - Insomnia_</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zytpca.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Insomniac&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【NOTE】Windows的磁盘操作"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-10 11:28" pubdate>
          2024年4月10日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          88 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【NOTE】Windows的磁盘操作</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><font style="color:rgb(51, 51, 51);">一、基本概念</font></h1><p><font style="color:rgb(51, 51, 51);">首先说明一点，本文中使用的不是cmd命令行，基于以下几点原因：</font></p>
<p><font style="color:rgb(51, 51, 51);">1．在C&#x2F;C++中调用系统命令会存在处理的种种不方便，需要大量额外的代码去分析命令执行结果。</font></p>
<p><font style="color:rgb(51, 51, 51);">2．windows命令行远不如linux的shell来的强大。</font></p>
<p><font style="color:rgb(51, 51, 51);">3．效率。</font></p>
<p><font style="color:rgb(51, 51, 51);">当然，如果不考虑编码，仅作为系统下一种应用工具的话，DiskPart是既安全又便利的选择。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">我们先来看几个主要的使用频繁的函数。</font></p>
<p><font style="color:rgb(51, 51, 51);">在windows下与磁盘打交道最主要的API就是</font><font style="color:rgb(255, 0, 0);">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">了，以下是从MSDN中直接拷贝出来的对该函数的说明。此函数确实太重要也太强大了，建议大家耐着性子先将它的说明看完，当然，本文后续例子中会大量用到此函数，可随时返回此节参阅。</font></p>
<h2 id="deviceIoControl-函数-ioapiset-h"><a href="#deviceIoControl-函数-ioapiset-h" class="headerlink" title="deviceIoControl 函数 (ioapiset.h)"></a><font style="color:rgb(22, 22, 22);">deviceIoControl 函数 (ioapiset.h)</font></h2><p><font style="color:rgb(22, 22, 22);">将控制代码直接发送到指定的设备驱动程序，导致相应的设备执行相应的操作。</font></p>
<p><font style="color:rgb(22, 22, 22);">请参阅</font><font style="color:rgb(22, 22, 22);"> </font><a target="_blank" rel="noopener" href="https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io/dledit"><font style="color:rgb(0, 101, 179);">分配驱动器号示例</font></a><font style="color:rgb(22, 22, 22);">。</font></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><font style="color:rgb(22, 22, 22);">语法</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">DeviceIoControl</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]                HANDLE       hDevice,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]                DWORD        dwIoControlCode,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional]      LPVOID       lpInBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]                DWORD        nInBufferSize,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional]     LPVOID       lpOutBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]                DWORD        nOutBufferSize,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional]     LPDWORD      lpBytesReturned,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><font style="color:rgb(22, 22, 22);">参数</font></h3><p><code>[in] hDevice</code></p>
<p>要对其执行操作的设备句柄。 设备通常是卷、目录、文件或流。 若要检索设备句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数。 有关详细信息，请参阅“备注”。</p>
<p><code>[in] dwIoControlCode</code></p>
<p>操作的控制代码。 此值标识要执行的特定操作以及要执行该操作的设备类型。</p>
<p>有关控制代码的列表，请参阅备注。 每个控件代码的文档都提供了 <em>lpInBuffer</em>、 <em>nInBufferSize</em>、 <em>lpOutBuffer</em> 和 <em>nOutBufferSize</em> 参数的用法详细信息。</p>
<p><code>[in, optional] lpInBuffer</code></p>
<p>指向输入缓冲区的指针，其中包含执行操作所需的数据。 此数据的格式取决于 <em>dwIoControlCode</em> 参数的值。</p>
<p>如果 <em>dwIoControlCode</em> 指定不需要输入数据的操作，则此参数可以为 <strong>NULL</strong>。</p>
<p><code>[in] nInBufferSize</code></p>
<p>输入缓冲区的大小（以字节为单位）。</p>
<p><code>[out, optional] lpOutBuffer</code></p>
<p>指向输出缓冲区的指针，用于接收操作返回的数据。 此数据的格式取决于 <em>dwIoControlCode</em> 参数的值。</p>
<p>如果 <em>dwIoControlCode</em> 指定不返回数据的操作，则此参数可以为 <strong>NULL</strong>。</p>
<p><code>[in] nOutBufferSize</code></p>
<p>输出缓冲区的大小（以字节为单位）。</p>
<p><code>[out, optional] lpBytesReturned</code></p>
<p>指向变量的指针，该变量接收存储在输出缓冲区中的数据的大小（以字节为单位）。</p>
<p>如果输出缓冲区太小而无法接收任何数据，则调用失败，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 将返回_ERROR_INSUFFICIENT_BUFFER，lpBytesReturned_ 为零。</p>
<p>如果输出缓冲区太小，无法容纳所有数据，但可以容纳一些条目，则某些驱动程序将返回尽可能多的数据。 在这种情况下，调用失败，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回_ERROR_MORE_DATA，lpBytesReturned_ 指示接收的数据量。 应用程序应再次使用相同的操作调用 <strong>DeviceIoControl</strong> ，并指定一个新的起点。</p>
<p>如果 lpOverlapped 为 NULL，则 lpBytesReturned 不能为 NULL。 即使操作不返回输出数据且 <em>lpOutBuffer</em> 为 <strong>NULL，DeviceIoControl</strong> 也会使用 <em>lpBytesReturned</em>。 执行此类操作后，lpBytesReturned 的值毫无意义。</p>
<p>如果 lpOverlapped 不为 NULL，则 lpBytesReturned 可以为 NULL。 如果此参数不为 NULL 且操作返回数据，则 lpBytesReturned 在重叠操作完成之前毫无意义。 若要检索返回的字节数，请调用 GetOverlappedResult。 如果 hDevice 与 I&#x2F;O 完成端口相关联，则可以通过调用 GetQueuedCompletionStatus 来检索返回的字节数。</p>
<p><code>[in, out, optional] lpOverlapped</code></p>
<p>指向 OVERLAPPED 结构的指针。</p>
<p>如果在未指定 FILE_FLAG_OVERLAPPED 的情况下打开 hDevice，则忽略 lpOverlapped。</p>
<p>如果使用 FILE_FLAG_OVERLAPPED 标志打开 hDevice，则此操作将作为重叠（异步）操作执行。 在这种情况下，lpOverlapped 必须指向包含事件对象句柄的有效 OVERLAPPED 结构。 否则，函数会以不可预知的方式失败。</p>
<p>对于重叠操作，DeviceIoControl 会立即返回，并在操作完成时向事件对象发出信号。 否则，在操作完成或发生错误之前，函数不会返回。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><font style="color:rgb(22, 22, 22);">返回值</font></h3><p><font style="color:rgb(22, 22, 22);">如果操作成功完成，则返回值为非零 (TRUE) 。</font></p>
<p><font style="color:rgb(22, 22, 22);">如果操作失败或挂起，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</font></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a><font style="color:rgb(22, 22, 22);">注解</font></h3><p><font style="color:rgb(22, 22, 22);">若要检索设备的句柄，必须使用设备的名称或与设备关联的驱动程序的名称调用</font><font style="color:rgb(22, 22, 22);"> </font><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><font style="color:rgb(0, 101, 179);">CreateFile</font></a><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">函数。 若要指定设备名称，请使用以下格式：</font></p>
<p>\._DeviceName_</p>
<p><strong><font style="color:rgb(22, 22, 22);">DeviceIoControl</font></strong><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">可以接受特定设备的句柄。 例如，若要使用</font><font style="color:rgb(22, 22, 22);"> </font><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><font style="color:rgb(0, 101, 179);">CreateFile</font></a><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">打开逻辑驱动器 A： 的句柄，请指定 \.\a：。 或者，可以使用名称 \.\PhysicalDrive0、.\PhysicalDrive1 等打开系统上物理驱动器的句柄。</font></p>
<p><font style="color:rgb(22, 22, 22);">调用</font><font style="color:rgb(22, 22, 22);"> </font><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><font style="color:rgb(0, 101, 179);">CreateFile</font></a><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">以打开设备驱动程序的句柄时，应指定</font><strong><font style="color:rgb(22, 22, 22);">FILE_SHARE_READ</font></strong><font style="color:rgb(22, 22, 22);">和</font><strong><font style="color:rgb(22, 22, 22);">FILE_SHARE_WRITE</font></strong><font style="color:rgb(22, 22, 22);">访问标志。 但是，打开通信资源（如串行端口）时，必须指定独占访问。 打开设备句柄时，请使用其他</font><font style="color:rgb(22, 22, 22);"> </font><strong><font style="color:rgb(22, 22, 22);">CreateFile</font></strong><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">参数，如下所示：</font></p>
<ul>
<li><em><font style="color:rgb(22, 22, 22);">fdwCreate</font></em><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">参数必须指定</font><strong><font style="color:rgb(22, 22, 22);">OPEN_EXISTING</font></strong><font style="color:rgb(22, 22, 22);">。</font></li>
<li><em><font style="color:rgb(22, 22, 22);">hTemplateFile</font></em><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">参数必须为</font><font style="color:rgb(22, 22, 22);"> </font><strong><font style="color:rgb(22, 22, 22);">NULL</font></strong><font style="color:rgb(22, 22, 22);">。</font></li>
<li><em><font style="color:rgb(22, 22, 22);">fdwAttrsAndFlags</font></em><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">参数可以指定</font><strong><font style="color:rgb(22, 22, 22);">FILE_FLAG_OVERLAPPED</font></strong><font style="color:rgb(22, 22, 22);">，以指示返回的句柄可用于重叠 (异步) I&#x2F;O 操作。</font></li>
</ul>
<p><font style="color:rgb(22, 22, 22);">有关受支持的控制代码的列表，请参阅以下主题：</font></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/storage/cd-rom-io-control-codes"><font style="color:rgb(0, 101, 179);">CD-ROM 控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-control-codes"><font style="color:rgb(0, 101, 179);">通信控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/device-management-control-codes"><font style="color:rgb(0, 101, 179);">设备管理控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/directory-management-control-codes"><font style="color:rgb(0, 101, 179);">目录管理控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/disk-management-control-codes"><font style="color:rgb(0, 101, 179);">磁盘管理控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-management-control-codes"><font style="color:rgb(0, 101, 179);">文件管理控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Power/power-management-control-codes"><font style="color:rgb(0, 101, 179);">电源管理控制代码</font></a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/volume-management-control-codes"><font style="color:rgb(0, 101, 179);">卷管理控制代码</font></a></li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><font style="color:rgb(22, 22, 22);">示例</font></h4><p><font style="color:rgb(22, 22, 22);">有关使用</font><font style="color:rgb(22, 22, 22);"> </font><strong><font style="color:rgb(22, 22, 22);">DeviceIoControl</font></strong><font style="color:rgb(22, 22, 22);"> </font><font style="color:rgb(22, 22, 22);">的示例，请参阅</font><font style="color:rgb(22, 22, 22);"> </font><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol"><font style="color:rgb(0, 101, 179);">调用 DeviceIoControl</font></a><font style="color:rgb(22, 22, 22);">。</font></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a><font style="color:rgb(22, 22, 22);">要求</font></h3><p><strong>展开表</strong></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:rgb(22, 22, 22);">要求</font></th>
<th align="left"><font style="color:rgb(22, 22, 22);">值</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">最低受支持的客户端</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">Windows XP</font></td>
</tr>
<tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">最低受支持的服务器</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">Windows Server 2003</font></td>
</tr>
<tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">目标平台</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">Windows</font></td>
</tr>
<tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">标头</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">ioapiset.h (包括 Windows.h)</font></td>
</tr>
<tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">Library</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">Kernel32.lib</font></td>
</tr>
<tr>
<td align="left"><strong><font style="color:rgb(22, 22, 22);">DLL</font></strong></td>
<td align="left"><font style="color:rgb(22, 22, 22);">Kernel32.dll</font></td>
</tr>
</tbody></table>
<h3 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a><font style="color:rgb(22, 22, 22);">另请参阅</font></h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/synchapi/nf-synchapi-createeventa"><font style="color:rgb(0, 101, 179);">CreateEvent</font></a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><font style="color:rgb(0, 101, 179);">CreateFile</font></a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/device-input-and-output-control-ioctl-"><font style="color:rgb(0, 101, 179);">设备输入和输出控制 (IOCTL)</font></a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult"><font style="color:rgb(0, 101, 179);">GetOverlappedResult</font></a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><font style="color:rgb(0, 101, 179);">GetQueuedCompletionStatus</font></a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped"><font style="color:rgb(0, 101, 179);">OVERLAPPED</font></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io/dledit"><font style="color:rgb(0, 101, 179);">分配驱动器号示例</font></a></p>
<hr>
<p><font style="color:rgb(51, 51, 51);">该函数实现对设备的访问，包括获取信息，发送命令，交换数据等。可以利用该接口函数向指定的设备驱动发送正确的控制码及数据，分析它的响应，执行程序设计人员想要的功能。磁盘操作只是它强大功能中的一小部分。</font></p>
<p><font style="color:rgb(51, 51, 51);">该函数最重要的两个参数是</font><font style="color:rgb(0, 0, 255);">hDevice</font><font style="color:rgb(51, 51, 51);">和</font><font style="color:rgb(0, 0, 255);">dwIoControlCode</font><font style="color:rgb(51, 51, 51);">.</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">控制码</font><font style="color:rgb(0, 0, 255);">dwIoControlCode</font><font style="color:rgb(51, 51, 51);">决定了操作类型，与磁盘相关的控制码有</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">IOCTL_DISK_CREATE_DISK    利用CREATE_DISK结构中的信息对指定磁盘和磁盘分区进行初始化。<br>IOCTL_DISK_DELETE_DRIVE_LAYOUT    从主引导记录中删除引导信息，所以磁盘将会被从头到尾的格式化。扇区0中的分区信息也就不复存在了。<br>IOCTL_DISK_FORMAT_TRACKS    格式化指定的、连续的软盘磁道。如果需要更多的功能请使用IOCTL_DISK_FORMAT_TRACKS_EX。<br>IOCTL_DISK_FORMAT_TRACKS_EX    格式化指定的、连续的软盘磁道。<br>IOCTL_DISK_GET_CACHE_INFORMATION    返回磁盘的高速缓存配置数据<br>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX    返回物理磁盘的扩展信息。包括：类型、柱面数量、每柱面磁道数、每磁道扇区数和每扇区字节数等。<br>IOCTL_DISK_GET_DRIVE_LAYOUT_EX    返回各分区的扩展信息以及这些分区的特性。更多信息请参照DRIVE_LAYOUT_INFORMATION_EX结构。<br>IOCTL_DISK_GET_LENGTH_INFO    返回指定磁盘/卷/分区的大小信息<br>IOCTL_DISK_GET_PARTITION_INFO_EX    返回指定分区的扩展信息。包括：分区类型、大小和种类。更多信息请参照PARTITION_INFORMATION_EX结构。<br>IOCTL_DISK_GROW_PARTITION    扩大指定分区。<br>IOCTL_DISK_IS_WRITABLE    确定指定磁盘是否可写。<br>IOCTL_DISK_PERFORMANCE    启用并获取磁盘性能统计<br>IOCTL_DISK_PERFORMANCE_OFF    关闭磁盘性能统计<br>IOCTL_DISK_REASSIGN_BLOCKS    使磁盘设备影射一块区域做为它的备用存储块公用池（spare block pool）。<br>IOCTL_DISK_SET_CACHE_INFORMATION    设置磁盘的配置信息<br>IOCTL_DISK_SET_DRIVE_LAYOUT_EX    根据给定的磁盘信息对磁盘进行分区。<br>IOCTL_DISK_SET_PARTITION_INFO_EX    设置指定分区的分区信息。包括AT和EFI (Extensible Firmware Interface)分区的布局信息。<br>IOCTL_DISK_UPDATE_PROPERTIES    使缓冲的分区表无效并重新获取一份。<br>IOCTL_DISK_VERIFY    对指定磁盘进行逻辑格式化<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);"></font></p>
<p><font style="color:rgb(51, 51, 51);">另一个参数</font><font style="color:rgb(0, 0, 255);">hDevice</font><font style="color:rgb(51, 51, 51);">指向要操作的设备句柄，调用函数</font><font style="color:rgb(255, 0, 0);">CreateFile</font><font style="color:rgb(51, 51, 51);">获得。</font><font style="color:rgb(255, 0, 0);">CreateFile</font><font style="color:rgb(51, 51, 51);">函数原型为</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE WINAPI <span class="hljs-title">CreateFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          LPCTSTR lpFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          DWORD dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          DWORD dwShareMode,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          DWORD dwCreationDisposition,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          DWORD dwFlagsAndAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">    __in          HANDLE hTemplateFile</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">lpFileName为需要打开设备的名称，对于磁盘来说，可能为以下几种形式：</font></p>
<p><font style="color:rgb(51, 51, 51);">对于物理驱动器x，形式为</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">\.\PhysicalDriveX</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">，编号从0开始，例如</font></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:rgb(51, 51, 51);">名称</font></th>
<th align="left"><font style="color:rgb(51, 51, 51);">含义</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(51, 51, 51);">\.\PhysicalDrive0</font></td>
<td align="left"><font style="color:rgb(51, 51, 51);">打开第一个物理驱动器</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(51, 51, 51);">\.\PhysicalDrive2</font></td>
<td align="left"><font style="color:rgb(51, 51, 51);">打开第三个物理驱动器</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(51, 51, 51);">对于逻辑分区（卷），形式为</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">\.\X</font><font style="color:rgb(51, 51, 51);">: ，例如</font></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:rgb(51, 51, 51);">名称</font></th>
<th align="left"><font style="color:rgb(51, 51, 51);">含义</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(51, 51, 51);">\.\A:</font></td>
<td align="left"><font style="color:rgb(51, 51, 51);">打开A盘（软驱）</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(51, 51, 51);">\.\C:</font></td>
<td align="left"><font style="color:rgb(51, 51, 51);">打开C盘（磁盘逻辑分区）</font></td>
</tr>
</tbody></table>
<h2 id="调用-DeviceIoControl"><a href="#调用-DeviceIoControl" class="headerlink" title="调用 DeviceIoControl"></a><font style="color:rgb(22, 22, 22);">调用 DeviceIoControl</font></h2><p><font style="color:rgb(51, 51, 51);">最后复制一段MSDN上的示例代码作为本节的结束，该示例获取磁盘的详细信息（包括柱面、磁道、扇区等统计信息）并打印出来。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNICODE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _UNICODE 1</span><br><br><span class="hljs-comment">/* The code of interest is in the subroutine GetDriveGeometry. The </span><br><span class="hljs-comment">   code in main shows how to interpret the results of the call. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> wszDrive <span class="hljs-string">L&quot;\\\\.\\PhysicalDrive0&quot;</span></span><br><br><span class="hljs-function">BOOL <span class="hljs-title">GetDriveGeometry</span><span class="hljs-params">(LPWSTR wszPath, DISK_GEOMETRY *pdg)</span></span><br><span class="hljs-function"></span>&#123;<br>  HANDLE hDevice = INVALID_HANDLE_VALUE;  <span class="hljs-comment">// handle to the drive to be examined </span><br>  BOOL bResult   = FALSE;                 <span class="hljs-comment">// results flag</span><br>  DWORD junk     = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// discard results</span><br><br>  hDevice = <span class="hljs-built_in">CreateFileW</span>(wszPath,          <span class="hljs-comment">// drive to open</span><br>                        <span class="hljs-number">0</span>,                <span class="hljs-comment">// no access to the drive</span><br>                        FILE_SHARE_READ | <span class="hljs-comment">// share mode</span><br>                        FILE_SHARE_WRITE, <br>                        <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                        OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                        <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                        <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// do not copy file attributes</span><br><br>  <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)    <span class="hljs-comment">// cannot open the drive</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> (FALSE);<br>  &#125;<br><br>  bResult = <span class="hljs-built_in">DeviceIoControl</span>(hDevice,                       <span class="hljs-comment">// device to be queried</span><br>                            IOCTL_DISK_GET_DRIVE_GEOMETRY, <span class="hljs-comment">// operation to perform</span><br>                            <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,                       <span class="hljs-comment">// no input buffer</span><br>                            pdg, <span class="hljs-built_in">sizeof</span>(*pdg),            <span class="hljs-comment">// output buffer</span><br>                            &amp;junk,                         <span class="hljs-comment">// # bytes returned</span><br>                            (LPOVERLAPPED) <span class="hljs-literal">NULL</span>);          <span class="hljs-comment">// synchronous I/O</span><br><br>  <span class="hljs-built_in">CloseHandle</span>(hDevice);<br><br>  <span class="hljs-keyword">return</span> (bResult);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">wchar_t</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  DISK_GEOMETRY pdg = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// disk drive geometry structure</span><br>  BOOL bResult = FALSE;      <span class="hljs-comment">// generic results flag</span><br>  ULONGLONG DiskSize = <span class="hljs-number">0</span>;    <span class="hljs-comment">// size of the drive, in bytes</span><br><br>  bResult = <span class="hljs-built_in">GetDriveGeometry</span> (wszDrive, &amp;pdg);<br><br>  <span class="hljs-keyword">if</span> (bResult) <br>  &#123;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Drive path      = %ws\n&quot;</span>,   wszDrive);<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Cylinders       = %I64d\n&quot;</span>, pdg.Cylinders);<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Tracks/cylinder = %ld\n&quot;</span>,   (ULONG) pdg.TracksPerCylinder);<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Sectors/track   = %ld\n&quot;</span>,   (ULONG) pdg.SectorsPerTrack);<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Bytes/sector    = %ld\n&quot;</span>,   (ULONG) pdg.BytesPerSector);<br><br>    DiskSize = pdg.Cylinders.QuadPart * (ULONG)pdg.TracksPerCylinder *<br>               (ULONG)pdg.SectorsPerTrack * (ULONG)pdg.BytesPerSector;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Disk size       = %I64d (Bytes)\n&quot;</span><br>            <span class="hljs-string">L&quot;                = %.2f (Gb)\n&quot;</span>, <br>            DiskSize, (<span class="hljs-type">double</span>) DiskSize / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>  &#125; <br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-built_in">wprintf</span> (<span class="hljs-string">L&quot;GetDriveGeometry failed. Error %ld.\n&quot;</span>, <span class="hljs-built_in">GetLastError</span> ());<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ((<span class="hljs-type">int</span>)bResult);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="二、初始化磁盘"><a href="#二、初始化磁盘" class="headerlink" title="二、初始化磁盘"></a><font style="color:rgb(23, 35, 63);">二、初始化磁盘</font></h1><p><font style="color:rgb(23, 35, 63);">上一节中我们介绍了一些基本概念和主要的API，本节开始我们将列举并分析一些实例。本文中的所有代码我都在vs2008下测试过，读者只需要替换少量的宏定义即可编译执行。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">面对一块新的磁盘，我们首先要做的就是对其初始化。在系统中通过</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">的磁盘管理完成这一点非常容易，但在程序中实现略微复杂。本节的示例代码对一块新硬盘初始化，并在上面创建分区。</font></p>
<h3 id="初始化磁盘代码"><a href="#初始化磁盘代码" class="headerlink" title="初始化磁盘代码"></a><font style="color:rgb(23, 35, 63);">初始化磁盘</font><font style="color:rgb(51, 51, 51);">代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: initialize the disk and create partitions</span><br><span class="hljs-comment">* input: disk, disk name</span><br><span class="hljs-comment">*        parNum, partition number</span><br><span class="hljs-comment">* output: N/A</span><br><span class="hljs-comment">* return: Succeed, 0</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">CreateDisk</span><span class="hljs-params">(DWORD disk, WORD partNum)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hDevice;               <span class="hljs-comment">// handle to the drive to be examined</span><br>    BOOL result;                  <span class="hljs-comment">// results flag</span><br>    DWORD readed;                 <span class="hljs-comment">// discard results</span><br>    DWORD ret;<br>    WORD i;<br>    CHAR diskPath[DISK_PATH_LEN];<br>    DISK_GEOMETRY pdg;<br>    DWORD sectorSize;<br>    DWORD signature;<br>    LARGE_INTEGER diskSize;<br>    LARGE_INTEGER partSize;<br>    BYTE actualPartNum;<br>   <br>    DWORD layoutStructSize;<br>    DRIVE_LAYOUT_INFORMATION_EX *dl;<br>    CREATE_DISK newDisk;<br> <br>    <span class="hljs-built_in">sprintf</span>(diskPath, <span class="hljs-string">&quot;\\\\.\\PhysicalDrive%d&quot;</span>, disk);<br> <br>    actualPartNum = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (partNum &gt; actualPartNum)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (WORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>   <br>    hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                diskPath,<br>                GENERIC_READ|GENERIC_WRITE,<br>                FILE_SHARE_READ|FILE_SHARE_WRITE,<br>                <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">//default security attributes  </span><br>                OPEN_EXISTING, <span class="hljs-comment">// disposition  </span><br>                <span class="hljs-number">0</span>,              <span class="hljs-comment">// file attributes  </span><br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">// Create primary partition MBR</span><br>    newDisk.PartitionStyle = PARTITION_STYLE_MBR;<br>    signature = (DWORD)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">//get signature from current time</span><br>    newDisk.Mbr.Signature = signature;<br>   <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,<br>                IOCTL_DISK_CREATE_DISK,<br>                &amp;newDisk,<br>                <span class="hljs-built_in">sizeof</span>(CREATE_DISK),<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                &amp;readed,<br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_CREATE_DISK Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//fresh the partition table</span><br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,<br>                IOCTL_DISK_UPDATE_PROPERTIES,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                &amp;readed,<br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_UPDATE_PROPERTIES Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//Now create the partitions</span><br>    ret = <span class="hljs-built_in">GetDriveGeometry</span>(diskPath, &amp;pdg);<br>    <span class="hljs-keyword">if</span> ((DWORD)<span class="hljs-number">-1</span> == ret)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    sectorSize = pdg.BytesPerSector;<br>    diskSize.QuadPart = pdg.Cylinders.QuadPart * pdg.TracksPerCylinder *<br>                        pdg.SectorsPerTrack * pdg.BytesPerSector;       <span class="hljs-comment">//calculate the disk size;</span><br>    partSize.QuadPart = diskSize.QuadPart / partNum;<br> <br>    layoutStructSize = <span class="hljs-built_in">sizeof</span>(DRIVE_LAYOUT_INFORMATION_EX) + (actualPartNum - <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(PARTITION_INFORMATION_EX);<br>    dl = (DRIVE_LAYOUT_INFORMATION_EX*)<span class="hljs-built_in">malloc</span>(layoutStructSize);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == dl)<br>    &#123;<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> (WORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    dl-&gt;PartitionStyle = (DWORD)PARTITION_STYLE_MBR;<br>    dl-&gt;PartitionCount = actualPartNum;<br>    dl-&gt;Mbr.Signature = signature;<br> <br>    <span class="hljs-comment">//clear the unused partitions</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; actualPartNum; i++)&#123;<br>        dl-&gt;PartitionEntry[i].RewritePartition = <span class="hljs-number">1</span>;<br>        dl-&gt;PartitionEntry[i].Mbr.PartitionType = PARTITION_ENTRY_UNUSED;<br>    &#125;<br>    <span class="hljs-comment">//set the profile of the partitions</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; partNum; i++)&#123;<br>        dl-&gt;PartitionEntry[i].PartitionStyle = PARTITION_STYLE_MBR;<br>        dl-&gt;PartitionEntry[i].StartingOffset.QuadPart =<br>            (partSize.QuadPart * i) + ((LONGLONG)(pdg.SectorsPerTrack) * (LONGLONG)(pdg.BytesPerSector));   <span class="hljs-comment">//32256</span><br>        dl-&gt;PartitionEntry[i].PartitionLength.QuadPart = partSize.QuadPart;<br>        dl-&gt;PartitionEntry[i].PartitionNumber = i + <span class="hljs-number">1</span>;<br>        dl-&gt;PartitionEntry[i].RewritePartition = TRUE;<br>        dl-&gt;PartitionEntry[i].Mbr.PartitionType = PARTITION_IFS;<br>        dl-&gt;PartitionEntry[i].Mbr.BootIndicator = FALSE;<br>        dl-&gt;PartitionEntry[i].Mbr.RecognizedPartition = TRUE;<br>        dl-&gt;PartitionEntry[i].Mbr.HiddenSectors =<br>            pdg.SectorsPerTrack + (DWORD)((partSize.QuadPart / sectorSize) * i);<br>    &#125;<br>    <span class="hljs-comment">//execute the layout  </span><br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,<br>                IOCTL_DISK_SET_DRIVE_LAYOUT_EX,<br>                dl,<br>                layoutStructSize,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                &amp;readed,<br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_SET_DRIVE_LAYOUT_EX Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-built_in">free</span>(dl);<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//fresh the partition table</span><br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,<br>                IOCTL_DISK_UPDATE_PROPERTIES,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                &amp;readed,<br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_UPDATE_PROPERTIES Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-built_in">free</span>(dl);<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">free</span>(dl);<br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3000</span>);            <span class="hljs-comment">//wait the operations take effect</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">函数</font><font style="color:rgb(255, 0, 0);">CreateDisk</font><font style="color:rgb(51, 51, 51);">包含两个参数，</font></p>
<p><font style="color:rgb(0, 0, 255);">DWORD disk</font><font style="color:rgb(0, 0, 255);"> </font><font style="color:rgb(51, 51, 51);">填入物理驱动器号，参见第一节。</font></p>
<p><font style="color:rgb(0, 0, 255);">WORD partNum</font><font style="color:rgb(0, 0, 255);"> </font><font style="color:rgb(51, 51, 51);">表示需要创建的分区数，</font><font style="color:rgb(0, 0, 255);">partNum</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">&lt;&#x3D; 4</font><font style="color:rgb(51, 51, 51);">。</font></p>
<h3 id="函数的执行流程"><a href="#函数的执行流程" class="headerlink" title="函数的执行流程"></a><font style="color:rgb(51, 51, 51);">函数的执行流程</font></h3><p><font style="color:rgb(51, 51, 51);">解释如下：</font></p>
<p><font style="color:rgb(51, 51, 51);">&#x2F;<em><strong><strong><strong><strong><strong><strong><strong></font><font style="color:rgb(51, 51, 51);">初始化磁盘</font><font style="color:rgb(51, 51, 51);"></strong></strong></strong></strong></strong></strong></strong></em>**&#x2F;</font></p>
<p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">根据</font><font style="color:rgb(51, 51, 51);">disk</font><font style="color:rgb(51, 51, 51);">创建设备名称，</font><font style="color:rgb(51, 51, 51);">\\.\PhysicalDriveX</font><font style="color:rgb(51, 51, 51);">，这里由于要转义，所以</font><font style="color:rgb(51, 51, 51);">”\”</font><font style="color:rgb(51, 51, 51);">都写为</font><font style="color:rgb(51, 51, 51);">”\”</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:rgb(51, 51, 51);">CreateFile</font><font style="color:rgb(51, 51, 51);">打开设备文件，并获得句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">用操作码</font><font style="color:rgb(0, 0, 255);">IOCTL_DISK_CREATE_DISK</font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:rgb(255, 0, 0);">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数，初始化磁盘并创建分区表。</font></p>
<p><font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(0, 0, 255);">IOCTL_DISK_CREATE_DISK</font><font style="color:rgb(51, 51, 51);">操作码时，</font><font style="color:rgb(51, 51, 51);">lpInBuffer</font><font style="color:rgb(51, 51, 51);">要填入一个</font><font style="color:rgb(0, 0, 255);">CREATE_DISK</font><font style="color:rgb(51, 51, 51);">结构参数，其中包括分区表类型和磁盘签名等参数，详见</font><font style="color:rgb(51, 51, 51);">MSDN</font><font style="color:rgb(51, 51, 51);">。本例中创建</font><font style="color:rgb(51, 51, 51);">MBR</font><font style="color:rgb(51, 51, 51);">分区表，签名由当前时间产生。</font></p>
<p><font style="color:rgb(51, 51, 51);">4． </font><font style="color:rgb(51, 51, 51);">刷新分区表。注意，程序中任何时候对磁盘的分区信息进行了修改都需要调用操作码为</font><font style="color:rgb(0, 0, 255);">IOCTL_DISK_UPDATE_PROPERTIES</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:rgb(255, 0, 0);">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数来刷新分区表，是操作切实生效。</font></p>
<p><font style="color:rgb(51, 51, 51);">&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong></font><font style="color:rgb(51, 51, 51);">创建分区</font><font style="color:rgb(51, 51, 51);"></strong></strong></strong></strong></strong></strong></strong></strong>***&#x2F;</font></p>
<p><font style="color:rgb(51, 51, 51);">5． </font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:rgb(255, 0, 0);">GetDriveGeometry</font><font style="color:rgb(51, 51, 51);">获取磁盘信息（</font><font style="color:rgb(51, 51, 51);">GetDriveGeometry</font><font style="color:rgb(51, 51, 51);">参见上一节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624027">http://cutebunny.blog.51cto.com/301216/624027</a><font style="color:rgb(51, 51, 51);">）。由于创建分区时要填入分区大小信息，我们此处先计算磁盘总大小，然后除以</font><font style="color:rgb(51, 51, 51);">partNum</font><font style="color:rgb(51, 51, 51);">将字节数平均分配到各个分区。</font></p>
<p><font style="color:rgb(51, 51, 51);">6． </font><font style="color:rgb(51, 51, 51);">分配</font><font style="color:rgb(0, 0, 255);">DRIVE_LAYOUT_INFORMATION_EX</font><font style="color:rgb(51, 51, 51);">结构体空间。我们通过在这个结构体中填入数据来指定如何对硬盘进行分区。结构体定义如下</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_DRIVE_LAYOUT_INFORMATION_EX</span> &#123;<br>DWORD PartitionStyle;<br>DWORD PartitionCount;<br><span class="hljs-keyword">union</span> &#123;<br>    DRIVE_LAYOUT_INFORMATION_MBR Mbr;<br>    DRIVE_LAYOUT_INFORMATION_GPT Gpt;<br>&#125;;<br>PARTITION_INFORMATION_EX PartitionEntry[<span class="hljs-number">1</span>];<br>&#125; DRIVE_LAYOUT_INFORMATION_EX,<br> *PDRIVE_LAYOUT_INFORMATION_EX;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">      </font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">其中</font><font style="color:rgb(0, 0, 255);">PartitionCount</font><font style="color:rgb(51, 51, 51);">为</font><font style="color:rgb(51, 51, 51);">4</font><font style="color:rgb(51, 51, 51);">的倍数，为简化处理，我们这里定死为</font><font style="color:rgb(51, 51, 51);">4</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">      </font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">另外还要注意</font><font style="color:rgb(0, 0, 255);">PARTITION_INFORMATION_EX</font><font style="color:rgb(51, 51, 51);">型的数组</font><font style="color:rgb(0, 0, 255);">PartitionEntry[1]</font><font style="color:rgb(51, 51, 51);">。虽然结构体中只定义了一个元素，但事实上必须在其后补足</font><font style="color:rgb(51, 51, 51);">PartitionCount – 1</font><font style="color:rgb(51, 51, 51);">个元素。所以代码中为</font><font style="color:rgb(51, 51, 51);">DRIVE_LAYOUT_INFORMATION_EX *dl</font><font style="color:rgb(51, 51, 51);">分配空间的时候加上了</font><font style="color:rgb(51, 51, 51);">(actualPartNum - 1) * sizeof(PARTITION_INFORMATION_EX)</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">7． </font><font style="color:rgb(51, 51, 51);">在</font><font style="color:rgb(0, 0, 255);">DRIVE_LAYOUT_INFORMATION_EX</font><font style="color:rgb(51, 51, 51);">结构体空间</font><font style="color:rgb(51, 51, 51);">dl</font><font style="color:rgb(51, 51, 51);">中填入数据。</font></p>
<p><font style="color:rgb(51, 51, 51);">先将所有分区都设为</font><font style="color:rgb(0, 0, 255);">PARTITION_ENTRY_UNUSED</font><font style="color:rgb(51, 51, 51);">，后面具体分配多少个分区再设置回来。</font></p>
<p><font style="color:rgb(51, 51, 51);">然后再循环体内对每个分区的</font><font style="color:rgb(51, 51, 51);">PartitionEntry</font><font style="color:rgb(51, 51, 51);">赋值，其中</font></p>
<p><font style="color:rgb(51, 51, 51);">StartingOffset</font><font style="color:rgb(51, 51, 51);">除了跳过前面的分区已占据的空间外，还要加上</font><font style="color:rgb(51, 51, 51);">63</font><font style="color:rgb(51, 51, 51);">个扇区空间（</font><font style="color:rgb(51, 51, 51);">32256</font><font style="color:rgb(51, 51, 51);">字节）。</font></p>
<p><font style="color:rgb(51, 51, 51);">PartitionNumber</font><font style="color:rgb(51, 51, 51);">从</font><font style="color:rgb(51, 51, 51);">1</font><font style="color:rgb(51, 51, 51);">开始。</font></p>
<p><font style="color:rgb(51, 51, 51);">Mbr.PartitionType &#x3D; PARTITION_IFS</font><font style="color:rgb(51, 51, 51);">表示</font><font style="color:rgb(51, 51, 51);">NTFS</font><font style="color:rgb(51, 51, 51);">格式。</font></p>
<p><font style="color:rgb(51, 51, 51);">Mbr.HiddenSectors MSDN</font><font style="color:rgb(51, 51, 51);">上说</font><font style="color:rgb(51, 51, 51);">The number of hidden sectors to be allocated when the partition table is created.</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">我理解得不是很深刻，欢迎补充。</font></p>
<p><font style="color:rgb(51, 51, 51);">8． </font><font style="color:rgb(51, 51, 51);">调用操作码为</font><font style="color:rgb(0, 0, 255);">IOCTL_DISK_SET_DRIVE_LAYOUT_EX</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:rgb(255, 0, 0);">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数执行分区，参数需要填入刚才准备好的</font><font style="color:rgb(0, 0, 255);">DRIVE_LAYOUT_INFORMATION_EX</font><font style="color:rgb(51, 51, 51);">结构体和大小。</font></p>
<p><font style="color:rgb(51, 51, 51);">9． </font><font style="color:rgb(51, 51, 51);">刷新分区表，原理同</font><font style="color:rgb(51, 51, 51);">4</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">另外，我在函数末尾加上了</font><font style="color:rgb(51, 51, 51);">Sleep(3000)</font><font style="color:rgb(51, 51, 51);">。这是因为我发现创建分区操作需要一定的执行时间，如果后续紧跟着其它相关操作（例如格式化该分区）可能会产生分区不存在的错误，所以此处等待</font><font style="color:rgb(51, 51, 51);">3</font><font style="color:rgb(51, 51, 51);">秒确保其执行完毕。</font></p>
<p><font style="color:rgb(51, 51, 51);">本节涉及的类型较多，但各类型具有很强的关联性，读者可随时查阅MSDN获得更详细的说明。</font></p>
<hr>
<h1 id="三、获取和删除磁盘分区信息"><a href="#三、获取和删除磁盘分区信息" class="headerlink" title="三、获取和删除磁盘分区信息"></a><font style="color:rgb(23, 35, 63);">三、获取和删除磁盘分区信息</font></h1><p><font style="color:rgb(23, 35, 63);">上一节中介绍了如何初始化一块空白的磁盘，并创建分区。那么对于一块已存在分区的磁盘，我们如何获得其分区信息，如何删除其分区信息呢？本节对这两类操作进行讨论。</font></p>
<h3 id="获得磁盘分区信息的代码"><a href="#获得磁盘分区信息的代码" class="headerlink" title="获得磁盘分区信息的代码"></a><font style="color:rgb(51, 51, 51);">获得磁盘分区信息的代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get the disk&#x27;s drive layout infomation</span><br><span class="hljs-comment">* input: disk, disk name</span><br><span class="hljs-comment">* output: drive layout info</span><br><span class="hljs-comment">* return: Succeed, 0</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetDiskDriveLayout</span><span class="hljs-params">(<span class="hljs-type">const</span> CHAR *disk, DRIVE_LAYOUT_INFORMATION_EX *driveLayout)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hDevice;               <span class="hljs-comment">// handle to the drive to be examined</span><br>    BOOL result;                  <span class="hljs-comment">// results flag</span><br>    DWORD readed;                 <span class="hljs-comment">// discard results</span><br> <br>    hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                disk, <span class="hljs-comment">// drive to open</span><br>                GENERIC_READ | GENERIC_WRITE,     <span class="hljs-comment">// access to the drive</span><br>                FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-comment">//share mode</span><br>                <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// do not copy file attribute</span><br>                );<br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,               <span class="hljs-comment">// handle to device</span><br>                IOCTL_DISK_GET_DRIVE_LAYOUT_EX, <span class="hljs-comment">// dwIoControlCode</span><br>                <span class="hljs-literal">NULL</span>,                           <span class="hljs-comment">// lpInBuffer</span><br>                <span class="hljs-number">0</span>,                              <span class="hljs-comment">// nInBufferSize</span><br>                driveLayout,           <span class="hljs-comment">// output buffer</span><br>                <span class="hljs-built_in">sizeof</span>(*driveLayout),         <span class="hljs-comment">// size of output buffer</span><br>                &amp;readed,      <span class="hljs-comment">// number of bytes returned</span><br>                <span class="hljs-literal">NULL</span>     <span class="hljs-comment">// OVERLAPPED structure</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_GET_DRIVE_LAYOUT_EX Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">如果你已对上一节中创建分区的代码</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624052">http://cutebunny.blog.51cto.com/301216/624052</a><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">有了比较深刻的了解，那么这段代码就非常简单了。程序执行流程为：</font></p>
<p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">根据</font><font style="color:rgb(51, 51, 51);">disk</font><font style="color:rgb(51, 51, 51);">名称调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">打开设备句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">调用操作码为</font><font style="color:blue;">IOCTL_DISK_GET_DRIVE_LAYOUT_EX</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数获取分区信息。返回的信息存储在</font><font style="color:blue;">DRIVE_LAYOUT_INFORMATION_EX *driveLayout</font><font style="color:rgb(51, 51, 51);">中。本例中我们只考虑了一个分区的情况，如果有多个分区，适当调整</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数中的</font><font style="color:blue;">nOutBufferSize</font><font style="color:rgb(51, 51, 51);">参数即可。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． 解析</font><font style="color:blue;">*driveLayout</font><font style="color:rgb(51, 51, 51);">即可获得分区信息。</font></p>
<h3 id="删除磁盘分区信息的代码"><a href="#删除磁盘分区信息的代码" class="headerlink" title="删除磁盘分区信息的代码"></a><font style="color:rgb(51, 51, 51);">删除磁盘分区信息的代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: delete the partition layout of the disk</span><br><span class="hljs-comment">* input: disk, disk name</span><br><span class="hljs-comment">* output: N/A</span><br><span class="hljs-comment">* return: Succeed, 0</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">DestroyDisk</span><span class="hljs-params">(DWORD disk)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hDevice;               <span class="hljs-comment">// handle to the drive to be examined</span><br>    BOOL result;                  <span class="hljs-comment">// results flag</span><br>    DWORD readed;                 <span class="hljs-comment">// discard results</span><br>    CHAR diskPath[DISK_PATH_LEN];<br> <br>    <span class="hljs-built_in">sprintf</span>(diskPath, <span class="hljs-string">&quot;\\\\.\\PhysicalDrive%d&quot;</span>, disk);<br> <br>    hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                diskPath, <span class="hljs-comment">// drive to open</span><br>                GENERIC_READ | GENERIC_WRITE,     <span class="hljs-comment">// access to the drive</span><br>                FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-comment">//share mode</span><br>                <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// do not copy file attribute</span><br>                );<br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,               <span class="hljs-comment">// handle to device</span><br>                IOCTL_DISK_DELETE_DRIVE_LAYOUT, <span class="hljs-comment">// dwIoControlCode</span><br>                <span class="hljs-literal">NULL</span>,                           <span class="hljs-comment">// lpInBuffer</span><br>                <span class="hljs-number">0</span>,                              <span class="hljs-comment">// nInBufferSize</span><br>                <span class="hljs-literal">NULL</span>,                           <span class="hljs-comment">// lpOutBuffer</span><br>                <span class="hljs-number">0</span>,                              <span class="hljs-comment">// nOutBufferSize</span><br>                &amp;readed,      <span class="hljs-comment">// number of bytes returned</span><br>                <span class="hljs-literal">NULL</span>        <span class="hljs-comment">// OVERLAPPED structure</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-comment">//fprintf(stderr, &quot;IOCTL_DISK_DELETE_DRIVE_LAYOUT Error: %ld\n&quot;, GetLastError());</span><br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//fresh the partition table</span><br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,<br>                IOCTL_DISK_UPDATE_PROPERTIES,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-literal">NULL</span>,<br>                <span class="hljs-number">0</span>,<br>                &amp;readed,<br>                <span class="hljs-literal">NULL</span><br>                );<br>    <span class="hljs-keyword">if</span> (!result)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_DISK_UPDATE_PROPERTIES Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>       <br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">参数</font><font style="color:blue;">DWORD disk</font><font style="color:rgb(51, 51, 51);">为物理驱动器号。函数执行流程为：</font></p>
<p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">根据驱动器号生成设备名称。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">打开设备并获得设备句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">调用操作码为</font><font style="color:blue;">IOCTL_DISK_DELETE_DRIVE_LAYOUT</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数删除分区表。</font></p>
<p><font style="color:rgb(51, 51, 51);">4． </font><font style="color:rgb(51, 51, 51);">刷新分区表。</font></p>
<p><font style="color:rgb(51, 51, 51);">调用</font><font style="color:red;">DestroyDisk</font><font style="color:rgb(51, 51, 51);">后的磁盘在</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">磁盘管理中的状态为</font></p>
<p><img src="/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/image-0.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h1 id="四、根据逻辑分区号获得物理磁盘号"><a href="#四、根据逻辑分区号获得物理磁盘号" class="headerlink" title="四、根据逻辑分区号获得物理磁盘号"></a><font style="color:rgb(23, 35, 63);">四、根据逻辑分区号获得物理磁盘号</font></h1><p><font style="color:rgb(23, 35, 63);">第一节中</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624027">http://cutebunny.blog.51cto.com/301216/624027</a><font style="color:rgb(23, 35, 63);">我们谈到了磁盘设备名称的两种形式：</font></p>
<p><font style="color:black;">对于物理驱动器</font><font style="color:black;">x</font><font style="color:black;">，形式为</font><font style="color:blue;"> </font><font style="color:blue;">\.\PhysicalDriveX</font><font style="color:black;">，编号从</font><font style="color:black;">0</font><font style="color:black;">开始，例如</font></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:black;">名称</font></th>
<th align="left"><font style="color:black;">含义</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">\.\PhysicalDrive0</font></td>
<td align="left"><font style="color:black;">打开第一个物理驱动器</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">\.\PhysicalDrive2</font></td>
<td align="left"><font style="color:black;">打开第三个物理驱动器</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">对于逻辑分区（卷），形式为</font><font style="color:blue;"> </font><font style="color:blue;">\.\X</font><font style="color:black;">:</font><font style="color:black;"> </font><font style="color:black;">，例如</font></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:black;">名称</font></th>
<th align="left"><font style="color:black;">含义</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">\.\A:</font></td>
<td align="left"><font style="color:black;">打开</font><font style="color:black;">A</font><font style="color:black;">盘（软驱）</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">\.\C:</font></td>
<td align="left"><font style="color:black;">打开</font><font style="color:black;">C</font><font style="color:black;">盘（磁盘逻辑分区）</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(51, 51, 51);">那么如何找出物理驱动器号</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);">1</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);">2</font><font style="color:rgb(51, 51, 51);">……</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">和逻辑分区号</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">C, D, E</font><font style="color:rgb(51, 51, 51);">……之间的关系呢？本节讨论通过逻辑分区号获取所在物理驱动器号的方法，下一节讨论通过物理驱动器号找出其所包含的逻辑分区号的方法。当然，必定会存在其他思路实现同样的功能，欢迎大家补充。</font></p>
<p><font style="color:rgb(51, 51, 51);">首先我们要明确，物理驱动器号和逻辑分区号应该是一对多的关系。例如</font><font style="color:rgb(51, 51, 51);">disk0</font><font style="color:rgb(51, 51, 51);">可能包含</font><font style="color:rgb(51, 51, 51);">C, D, E</font><font style="color:rgb(51, 51, 51);">三个分区。所以下面讨论的函数</font><font style="color:red;">GetPhysicalDriveFromPartitionLetter</font><font style="color:rgb(51, 51, 51);">返回一个单独的整型数。</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">提供操作码</font><font style="color:blue;">IOCTL_STORAGE_GET_DEVICE_NUMBER</font><font style="color:rgb(51, 51, 51);">，可以非常方便的获得打开设备的设备类型和设备号。</font></p>
<h3 id="获得物理磁盘号代码"><a href="#获得物理磁盘号代码" class="headerlink" title="获得物理磁盘号代码"></a><font style="color:rgb(23, 35, 63);">获得物理磁盘号</font><font style="color:rgb(51, 51, 51);">代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get disk&#x27;s physical number from its drive letter</span><br><span class="hljs-comment">*           e.g. C--&gt;0 (C: is on disk0)</span><br><span class="hljs-comment">* input: letter, drive letter</span><br><span class="hljs-comment">* output: N/A</span><br><span class="hljs-comment">* return: Succeed, disk number</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetPhysicalDriveFromPartitionLetter</span><span class="hljs-params">(CHAR letter)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hDevice;               <span class="hljs-comment">// handle to the drive to be examined</span><br>    BOOL result;                 <span class="hljs-comment">// results flag</span><br>    DWORD readed;                   <span class="hljs-comment">// discard results</span><br>    STORAGE_DEVICE_NUMBER number;   <span class="hljs-comment">//use this to get disk numbers</span><br> <br>    CHAR path[DISK_PATH_LEN];<br>    <span class="hljs-built_in">sprintf</span>(path, <span class="hljs-string">&quot;\\\\.\\%c:&quot;</span>, letter);<br>    hDevice = <span class="hljs-built_in">CreateFile</span>(path, <span class="hljs-comment">// drive to open</span><br>                         GENERIC_READ | GENERIC_WRITE,    <span class="hljs-comment">// access to the drive</span><br>                         FILE_SHARE_READ | FILE_SHARE_WRITE,    <span class="hljs-comment">//share mode</span><br>                         <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                         OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                         <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                         <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// do not copy file attribute</span><br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                hDevice,                <span class="hljs-comment">// handle to device</span><br>                IOCTL_STORAGE_GET_DEVICE_NUMBER, <span class="hljs-comment">// dwIoControlCode</span><br>                <span class="hljs-literal">NULL</span>,                            <span class="hljs-comment">// lpInBuffer</span><br>                <span class="hljs-number">0</span>,                               <span class="hljs-comment">// nInBufferSize</span><br>                &amp;number,           <span class="hljs-comment">// output buffer</span><br>                <span class="hljs-built_in">sizeof</span>(number),         <span class="hljs-comment">// size of output buffer</span><br>                &amp;readed,       <span class="hljs-comment">// number of bytes returned</span><br>                <span class="hljs-literal">NULL</span>      <span class="hljs-comment">// OVERLAPPED structure</span><br>            );<br>    <span class="hljs-keyword">if</span> (!result) <span class="hljs-comment">// fail</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_STORAGE_GET_DEVICE_NUMBER Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//printf(&quot;%d %d %d\n\n&quot;, number.DeviceType, number.DeviceNumber, number.PartitionNumber);</span><br> <br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> number.DeviceNumber;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a><font style="color:rgb(51, 51, 51);">代码分析</font></h3><p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">根据分区号生成设备名称。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">打开设备并获得设备句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">调用操作码为</font><font style="color:blue;">IOCTL_STORAGE_GET_DEVICE_NUMBER</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数，输出为结构体变量</font><font style="color:blue;">STORAGE_DEVICE_NUMBER number</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">结构体</font><font style="color:blue;">STORAGE_DEVICE_NUMBER</font><font style="color:rgb(51, 51, 51);">定义为</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_STORAGE_DEVICE_NUMBER</span> &#123;<br>DEVICE_TYPE  DeviceType;<br>ULONG  DeviceNumber;<br>ULONG  PartitionNumber;<br>&#125; STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">      </font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">其中</font><font style="color:blue;">DeviceNumber</font><font style="color:rgb(51, 51, 51);">就是我们需要的物理磁盘号。</font></p>
<p><font style="color:rgb(51, 51, 51);">4． 返回</font><font style="color:blue;">DeviceNumber</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<hr>
<h1 id="五、获取物理磁盘上的所有逻辑分区号"><a href="#五、获取物理磁盘上的所有逻辑分区号" class="headerlink" title="五、获取物理磁盘上的所有逻辑分区号"></a><font style="color:rgb(23, 35, 63);">五、获取物理磁盘上的所有逻辑分区号</font></h1><p><font style="color:rgb(23, 35, 63);">本节讨论与上一节相反的操作，根据物理驱动器号获取该磁盘上的所有分区号。</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(23, 35, 63);">函数并没有提供操作码来直接完成此操作，所以需要稍微绕个圈子来实现这项功能。</font></p>
<p><font style="color:rgb(51, 51, 51);">大体思路为，先通过</font><font style="color:red;">GetLogicalDrives</font><font style="color:rgb(51, 51, 51);">函数获得系统中所有分区号，然后过滤掉非硬盘分区（例如软驱、光驱），再过滤掉不属于指定物理磁盘的分区，最后剩下的就是我们所需要的分区号了。</font></p>
<h3 id="获取逻辑分区号代码"><a href="#获取逻辑分区号代码" class="headerlink" title="获取逻辑分区号代码"></a><font style="color:rgb(23, 35, 63);">获取逻辑分区号</font><font style="color:rgb(51, 51, 51);">代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get disk&#x27;s drive letters from physical number</span><br><span class="hljs-comment">*           e.g. 0--&gt;&#123;C, D, E&#125; (disk0 has 3 drives, C:, D: and E:)</span><br><span class="hljs-comment">* input: phyDriveNumber, disk&#x27;s physical number</span><br><span class="hljs-comment">* output: letters, letters array</span><br><span class="hljs-comment">* return: Succeed, the amount of letters</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetPartitionLetterFromPhysicalDrive</span><span class="hljs-params">(DWORD phyDriveNumber, CHAR **letters)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD mask;<br>    DWORD driveType;<br>    DWORD bmLetters;<br>    DWORD diskNumber;<br>    CHAR path[DISK_PATH_LEN]; <br>    CHAR letter;<br>    DWORD letterNum;<br>    WORD i;<br>    CHAR *p;<br> <br>    bmLetters = <span class="hljs-built_in">GetLogicalDrives</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == bmLetters)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    letterNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(DWORD) * <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        mask = <span class="hljs-number">0x1u</span> &lt;&lt; i;<br>        <span class="hljs-keyword">if</span> ((mask &amp; bmLetters) == <span class="hljs-number">0</span>)        <span class="hljs-comment">//get one letter</span><br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        letter = (CHAR)(<span class="hljs-number">0x41</span> + i);    <span class="hljs-comment">//ASCII change</span><br>        <span class="hljs-built_in">sprintf</span>(path, <span class="hljs-string">&quot;%c:\\&quot;</span>, letter);<br>        driveType = <span class="hljs-built_in">GetDriveType</span>(path);<br>        <span class="hljs-keyword">if</span> (driveType != DRIVE_FIXED)<br>        &#123;<br>            bmLetters &amp;= ~mask;     <span class="hljs-comment">//clear this bit</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        diskNumber = <span class="hljs-built_in">GetPhysicalDriveFromPartitionLetter</span>(letter);<br>        <span class="hljs-keyword">if</span> (diskNumber != phyDriveNumber)<br>        &#123;<br>            bmLetters &amp;= ~mask;     <span class="hljs-comment">//clear this bit</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        letterNum++;<br>    &#125;<br> <br>    <span class="hljs-comment">//build the result</span><br>    *letters = (CHAR *)<span class="hljs-built_in">malloc</span>(letterNum);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == *letters)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>    p = *letters;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(DWORD) * <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        mask = <span class="hljs-number">0x1u</span> &lt;&lt; i;<br>        <span class="hljs-keyword">if</span> ((mask &amp; bmLetters) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        letter = (CHAR)(<span class="hljs-number">0x41</span> + i);    <span class="hljs-comment">//ASCII change</span><br>        *p = letter;<br>        p++;<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> letterNum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a><font style="color:rgb(51, 51, 51);">代码分析</font></h3><p><font style="color:rgb(51, 51, 51);">函数输入参数</font><font style="color:blue;">DWORD phyDriveNumber</font><font style="color:rgb(51, 51, 51);">为物理磁盘号，例如</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);">1</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);">2</font><font style="color:rgb(51, 51, 51);">……。</font></p>
<p><font style="color:rgb(51, 51, 51);">函数输出参数</font><font style="color:blue;">CHAR **letters</font><font style="color:rgb(51, 51, 51);">为获得的逻辑分区号数组指针。由于一块物理盘上可能有多个分区，所以用数组存放求得的多个分区号。</font></p>
<p><font style="color:rgb(51, 51, 51);">函数返回值为分区数量。</font></p>
<p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">调用函数</font><font style="color:red;">GetLogicalDrives</font><font style="color:rgb(51, 51, 51);">获得所有分区号。注意函数</font><font style="color:red;">GetLogicalDrives</font><font style="color:rgb(51, 51, 51);">返回值为位图形时，例如第</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">位代表</font><font style="color:rgb(51, 51, 51);">A:</font><font style="color:rgb(51, 51, 51);">，第</font><font style="color:rgb(51, 51, 51);">2</font><font style="color:rgb(51, 51, 51);">位代表</font><font style="color:rgb(51, 51, 51);">C:</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">等等。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">对获得的逻辑分区逐个检测。</font></p>
<p><font style="color:rgb(51, 51, 51);">调用函数</font><font style="color:red;">GetDriveType</font><font style="color:rgb(51, 51, 51);">获得分区类型，如果类型不为硬盘</font><font style="color:rgb(51, 51, 51);">(driveType !&#x3D; DRIVE_FIXED)</font><font style="color:rgb(51, 51, 51);">，将此位清</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">调用函数</font><font style="color:red;">GetPhysicalDriveFromPartitionLetter</font><font style="color:rgb(51, 51, 51);">（详见第四节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624379">http://cutebunny.blog.51cto.com/301216/624379</a><font style="color:rgb(51, 51, 51);">）查询该逻辑分区所属的物理分区号，如果不为</font><font style="color:blue;">phyDriveNumber</font><font style="color:rgb(51, 51, 51);">，将此位清</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">经过上两项条件过滤后的位图存储了我们所需的逻辑分区号。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">为</font><font style="color:rgb(51, 51, 51);">*letters</font><font style="color:rgb(51, 51, 51);">分配空间，并将位图转换为盘符字母存储在数组中。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<hr>
<h1 id="六、获取系统所在物理磁盘号"><a href="#六、获取系统所在物理磁盘号" class="headerlink" title="六、获取系统所在物理磁盘号"></a><font style="color:rgb(23, 35, 63);">六、获取系统所在物理磁盘号</font></h1><p><font style="color:rgb(23, 35, 63);">很多情况下，我们在程序中需要获知操作系统安装在哪个分区上或者哪个物理磁盘上，进而对其进行一些操作或避免一些操作。例如要避免对系统磁盘分区表的删除操作。本节讨论如何获取操作系统所在的逻辑分区号和物理驱动器号。</font></p>
<h3 id="获取操作系统所在的逻辑分区号和物理驱动器号代码"><a href="#获取操作系统所在的逻辑分区号和物理驱动器号代码" class="headerlink" title="获取操作系统所在的逻辑分区号和物理驱动器号代码"></a><font style="color:rgb(23, 35, 63);">获取操作系统所在的逻辑分区号和物理驱动器号</font><font style="color:rgb(51, 51, 51);">代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get the number of disk which the system installed on</span><br><span class="hljs-comment">* input: N/A</span><br><span class="hljs-comment">* output: N/A</span><br><span class="hljs-comment">* return: Succeed, disk number</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetSystemDiskPhysicalNumber</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR sysPath[DISK_PATH_LEN];<br>    CHAR diskLetter;<br>   DWORD diskNumber;<br>   <br>    DWORD ret = <span class="hljs-built_in">GetSystemDirectory</span>(sysPath, <span class="hljs-built_in">sizeof</span>(sysPath));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;GetSystemDirectory() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>    diskLetter = sysPath[<span class="hljs-number">0</span>];<br>    diskNumber = <span class="hljs-built_in">GetPhysicalDriveFromPartitionLetter</span>(diskLetter);<br>    <span class="hljs-keyword">return</span> diskNumber;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a><font style="color:rgb(51, 51, 51);">代码分析</font></h3><p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">先调用</font><font style="color:red;">GetSystemDirectory</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">函数获取</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">路径。</font><font style="color:blue;">sysPath</font><font style="color:rgb(51, 51, 51);">中存储的路径形式为</font><font style="color:rgb(51, 51, 51);">C:\WINDOWS\system32</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">截取</font><font style="color:blue;">sysPath</font><font style="color:rgb(51, 51, 51);">字符串的第一个字符，即可获得系统所在的分区盘符。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． 根据逻辑分区号，调用第四节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624379">http://cutebunny.blog.51cto.com/301216/624379</a><font style="color:rgb(51, 51, 51);">中讨论的</font><font style="color:red;">GetPhysicalDriveFromPartitionLetter</font><font style="color:rgb(51, 51, 51);">函数即可获得操作系统所在的物理磁盘号。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<hr>
<h1 id="七、获取当前所有的物理磁盘号"><a href="#七、获取当前所有的物理磁盘号" class="headerlink" title="七、获取当前所有的物理磁盘号"></a><font style="color:rgb(51, 51, 51);">七、获取当前所有的物理磁盘号</font></h1><p><font style="color:rgb(51, 51, 51);">有了前几节的基础后，本节给出一个更复杂但却非常实用的例子。</font></p>
<p><font style="color:rgb(51, 51, 51);">很多情况下，我们想知道当前系统下安装了多少块磁盘，他们的物理驱动器号都是多少，每一块磁盘上有多少个分区，分区号怎么分布，每个分区大小是多少。这就类似于我们打开</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">的磁盘管理看到的那种非常清晰的列表。对于后几个问题，我们根据物理驱动器号调用第五节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624567">http://cutebunny.blog.51cto.com/301216/624567</a><font style="color:rgb(51, 51, 51);">中的</font><font style="color:red;">GetPartitionLetterFromPhysicalDrive</font><font style="color:rgb(51, 51, 51);">函数，以及第三节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624079">http://cutebunny.blog.51cto.com/301216/624079</a><font style="color:rgb(51, 51, 51);">中的</font><font style="color:red;">GetDiskDriveLayout</font><font style="color:rgb(51, 51, 51);">函数即可搞定。那么我们这一节的重点放在如何获得当前所有物理驱动器号上。</font></p>
<p><font style="color:rgb(51, 51, 51);">先引入一个新的概念，设备</font><font style="color:rgb(51, 51, 51);">GUID</font><font style="color:rgb(51, 51, 51);">，它是同类设备统一并且唯一的标识码。对于磁盘，</font><font style="color:rgb(51, 51, 51);">GUID</font><font style="color:rgb(51, 51, 51);">为</font><font style="color:blue;">GUID_DEVINTERFACE_DISK</font><font style="color:rgb(51, 51, 51);">，具体值为</font><font style="color:rgb(51, 51, 51);">{53F56307-B6BF-11D0-94F2-00A0C91EFB8B}</font><font style="color:rgb(51, 51, 51);">。</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">提供一组</font><font style="color:rgb(51, 51, 51);">API</font><font style="color:rgb(51, 51, 51);">，可以通过</font><font style="color:rgb(51, 51, 51);">GUID</font><font style="color:rgb(51, 51, 51);">枚举出所有该类型的设备。先给出几个相关</font><font style="color:rgb(51, 51, 51);">API</font><font style="color:rgb(51, 51, 51);">的简要介绍</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HDEVINFO</span><br><span class="hljs-function">    <span class="hljs-title">SetupDiGetClassDevs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IN LPGUID  ClassGuid,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    IN PCTSTR  Enumerator,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    IN HWND  hwndParent,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    IN DWORD  Flags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">其中，</font><font style="color:blue;">ClassGuid</font><font style="color:rgb(51, 51, 51);">填入我们感兴趣的设备GUID，该函数返回满足查询条件的一组设备的信息集合的句柄，该句柄就是获取设备信息的关键钥匙。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">WINSETUPAPI BOOL WINAPI</span><br><span class="hljs-function">    <span class="hljs-title">SetupDiEnumDeviceInterfaces</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IN HDEVINFO  DeviceInfoSet,</span></span><br><span class="hljs-params"><span class="hljs-function">    IN PSP_DEVINFO_DATA  DeviceInfoData,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    IN LPGUID  InterfaceClassGuid,</span></span><br><span class="hljs-params"><span class="hljs-function">    IN DWORD  MemberIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">该函数枚举</font><font style="color:red;">SetupDiGetClassDevs</font><font style="color:rgb(51, 51, 51);">获得的句柄中包含的所有设备。参数</font><font style="color:blue;">DeviceInfoSet</font><font style="color:rgb(51, 51, 51);">填入我们上一步中获得的句柄，</font><font style="color:blue;">InterfaceClassGuid</font><font style="color:rgb(51, 51, 51);">仍旧是我们感兴趣的</font><font style="color:rgb(51, 51, 51);">GUID</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:blue;">MemberIndex</font><font style="color:rgb(51, 51, 51);">为设备在集合中的索引，从</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">开始计数，最后</font><font style="color:blue;">DeviceInterfaceData</font><font style="color:rgb(51, 51, 51);">是输出参数，存储枚举出的设备接口，后续可通过此接口获得详细的设备信息。</font></p>
<p><font style="color:rgb(51, 51, 51);">注意，参数</font><font style="color:blue;">DeviceInterfaceData.cbSize</font><font style="color:rgb(51, 51, 51);">在调用前必须初始化为sizeof(SP_DEVICE_INTERFACE_DATA)，这是函数的强制要求。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">WINSETUPAPI BOOL WINAPI</span><br><span class="hljs-function">    <span class="hljs-title">SetupDiGetDeviceInterfaceDetail</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IN HDEVINFO  DeviceInfoSet,</span></span><br><span class="hljs-params"><span class="hljs-function">    IN PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData,</span></span><br><span class="hljs-params"><span class="hljs-function">    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA  DeviceInterfaceDetailData,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    IN DWORD  DeviceInterfaceDetailDataSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    OUT PDWORD  RequiredSize,  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">    OUT PSP_DEVINFO_DATA  DeviceInfoData  OPTIONAL</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">该函数根据上两步中的句柄和接口获取设备的详细信息数据。参数</font><font style="color:blue;">DeviceInfoSet</font><font style="color:rgb(51, 51, 51);">和</font><font style="color:blue;">DeviceInterfaceData</font><font style="color:rgb(51, 51, 51);">在上两步中获得。输出参数</font><font style="color:blue;">DeviceInterfaceDetailData</font><font style="color:rgb(51, 51, 51);">存储着设备信息数据，这个结构体中的成员</font><font style="color:blue;">DevicePath</font><font style="color:rgb(51, 51, 51);">就是我们辛辛苦苦找寻的东西了。用它可以作为设备名调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">函数打开设备，之后的操作，嘿嘿，你懂的</font><font style="color:rgb(51, 51, 51);">…</font></p>
<h3 id="具体代码"><a href="#具体代码" class="headerlink" title=" 具体代码"></a><font style="color:rgb(51, 51, 51);"> 具体代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get device path from GUID</span><br><span class="hljs-comment">* input: lpGuid, GUID pointer</span><br><span class="hljs-comment">* output: pszDevicePath, device paths</span><br><span class="hljs-comment">* return: Succeed, the amount of found device paths</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetDevicePath</span><span class="hljs-params">(LPGUID lpGuid, CHAR **pszDevicePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    HDEVINFO hDevInfoSet;<br>    SP_DEVICE_INTERFACE_DATA ifdata;<br>    PSP_DEVICE_INTERFACE_DETAIL_DATA pDetail;<br>    DWORD nCount;<br>    BOOL result;<br> <br>    <span class="hljs-comment">//get a handle to a device information set</span><br>    hDevInfoSet = <span class="hljs-built_in">SetupDiGetClassDevs</span>(<br>                    lpGuid,      <span class="hljs-comment">// class GUID</span><br>                    <span class="hljs-literal">NULL</span>,        <span class="hljs-comment">// Enumerator</span><br>                    <span class="hljs-literal">NULL</span>,        <span class="hljs-comment">// hwndParent</span><br>                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE    <span class="hljs-comment">// present devices</span><br>                    );<br> <br>    <span class="hljs-comment">//fail...</span><br>    <span class="hljs-keyword">if</span> (hDevInfoSet == INVALID_HANDLE_VALUE)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_STORAGE_GET_DEVICE_NUMBER Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    pDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)<span class="hljs-built_in">malloc</span>(INTERFACE_DETAIL_SIZE);<br>    <span class="hljs-keyword">if</span> (pDetail == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>    pDetail-&gt;cbSize = <span class="hljs-built_in">sizeof</span>(SP_DEVICE_INTERFACE_DETAIL_DATA);<br> <br>    nCount = <span class="hljs-number">0</span>;<br>    result = TRUE;<br> <br>    <span class="hljs-comment">// device index = 0, 1, 2... test the device interface one by one</span><br>    <span class="hljs-keyword">while</span> (result)<br>    &#123;<br>        ifdata.cbSize = <span class="hljs-built_in">sizeof</span>(ifdata);<br> <br>        <span class="hljs-comment">//enumerates the device interfaces that are contained in a device information set</span><br>        result = <span class="hljs-built_in">SetupDiEnumDeviceInterfaces</span>(<br>                    hDevInfoSet,     <span class="hljs-comment">// DeviceInfoSet</span><br>                    <span class="hljs-literal">NULL</span>,            <span class="hljs-comment">// DeviceInfoData</span><br>                    lpGuid,          <span class="hljs-comment">// GUID</span><br>                    nCount,   <span class="hljs-comment">// MemberIndex</span><br>                    &amp;ifdata        <span class="hljs-comment">// DeviceInterfaceData</span><br>                    );<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            <span class="hljs-comment">// get details about a device interface</span><br>            result = <span class="hljs-built_in">SetupDiGetDeviceInterfaceDetail</span>(<br>                        hDevInfoSet,    <span class="hljs-comment">// DeviceInfoSet</span><br>                        &amp;ifdata,        <span class="hljs-comment">// DeviceInterfaceData</span><br>                        pDetail,        <span class="hljs-comment">// DeviceInterfaceDetailData</span><br>                        INTERFACE_DETAIL_SIZE,    <span class="hljs-comment">// DeviceInterfaceDetailDataSize</span><br>                        <span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// RequiredSize</span><br>                        <span class="hljs-literal">NULL</span>          <span class="hljs-comment">// DeviceInfoData</span><br>                        );<br>            <span class="hljs-keyword">if</span> (result)<br>            &#123;<br>                <span class="hljs-comment">// copy the path to output buffer</span><br>                <span class="hljs-built_in">strcpy</span>(pszDevicePath[nCount], pDetail-&gt;DevicePath);<br>                <span class="hljs-comment">//printf(&quot;%s\n&quot;, pDetail-&gt;DevicePath);</span><br>                nCount++;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-built_in">free</span>(pDetail);<br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">SetupDiDestroyDeviceInfoList</span>(hDevInfoSet);<br> <br>    <span class="hljs-keyword">return</span> nCount;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">执行完毕后，所有满足条件的磁盘设备名称都存储在字符串数组</font><font style="color:blue;">pszDevicePath</font><font style="color:rgb(51, 51, 51);">中。有了这个关键的数组，后面就可以为所欲为了。</font></p>
<h3 id="获得所有物理磁盘号的完整代码"><a href="#获得所有物理磁盘号的完整代码" class="headerlink" title="获得所有物理磁盘号的完整代码"></a><font style="color:rgb(51, 51, 51);">获得所有物理磁盘号的完整代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get all present disks&#x27; physical number</span><br><span class="hljs-comment">* input: N/A</span><br><span class="hljs-comment">* output: ppDisks, array of disks&#x27; physical number</span><br><span class="hljs-comment">* return: Succeed, the amount of present disks</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetAllPresentDisks</span><span class="hljs-params">(DWORD **ppDisks)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR *szDevicePath[MAX_DEVICE];        <span class="hljs-comment">// device path</span><br>    DWORD nDevice;<br>    HANDLE hDevice;<br>    STORAGE_DEVICE_NUMBER number;<br>    BOOL result;<br>    DWORD readed;<br>    WORD i, j;<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_DEVICE; i++)<br>    &#123;<br>        szDevicePath[i] = (CHAR *)<span class="hljs-built_in">malloc</span>(INTERFACE_DETAIL_SIZE);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == szDevicePath[i])<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            &#123;<br>                <span class="hljs-built_in">free</span>(szDevicePath[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// get the device paths</span><br>    nDevice = <span class="hljs-built_in">GetDevicePath</span>(<span class="hljs-built_in">const_cast</span>&lt;LPGUID&gt;(&amp;GUID_DEVINTERFACE_DISK), szDevicePath);<br>    <span class="hljs-keyword">if</span> ((DWORD)<span class="hljs-number">-1</span> == nDevice)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_DEVICE; i++)<br>        &#123;<br>            <span class="hljs-built_in">free</span>(szDevicePath[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    *ppDisks = (DWORD *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DWORD) * nDevice);<br>    <span class="hljs-comment">// get the disk&#x27;s physical number one by one</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nDevice; i++)<br>    &#123;<br>        hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                    szDevicePath[i], <span class="hljs-comment">// drive to open</span><br>                    GENERIC_READ | GENERIC_WRITE,     <span class="hljs-comment">// access to the drive</span><br>                    FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-comment">//share mode</span><br>                    <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                    OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                    <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                    <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// do not copy file attribute</span><br>                    );<br>        <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; MAX_DEVICE; j++)<br>            &#123;<br>                <span class="hljs-built_in">free</span>(szDevicePath[j]);<br>            &#125;<br>            <span class="hljs-built_in">free</span>(*ppDisks);<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                    hDevice,                <span class="hljs-comment">// handle to device</span><br>                    IOCTL_STORAGE_GET_DEVICE_NUMBER, <span class="hljs-comment">// dwIoControlCode</span><br>                    <span class="hljs-literal">NULL</span>,                            <span class="hljs-comment">// lpInBuffer</span><br>                    <span class="hljs-number">0</span>,                               <span class="hljs-comment">// nInBufferSize</span><br>                    &amp;number,           <span class="hljs-comment">// output buffer</span><br>                    <span class="hljs-built_in">sizeof</span>(number),         <span class="hljs-comment">// size of output buffer</span><br>                    &amp;readed,       <span class="hljs-comment">// number of bytes returned</span><br>                    <span class="hljs-literal">NULL</span>      <span class="hljs-comment">// OVERLAPPED structure</span><br>                    );<br>        <span class="hljs-keyword">if</span> (!result) <span class="hljs-comment">// fail</span><br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_STORAGE_GET_DEVICE_NUMBER Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; MAX_DEVICE; j++)<br>            &#123;<br>                <span class="hljs-built_in">free</span>(szDevicePath[j]);<br>            &#125;<br>            <span class="hljs-built_in">free</span>(*ppDisks);<br>            (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>            <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>        &#125;<br>        *(*ppDisks + i) = number.DeviceNumber;<br> <br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    &#125;<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_DEVICE; i++)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(szDevicePath[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nDevice;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a><font style="color:rgb(51, 51, 51);">代码说明</font></h3><p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">调用函数</font><font style="color:red;">GetDevicePath</font><font style="color:rgb(51, 51, 51);">获得前面所说的磁盘设备名称数组。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">对每一个磁盘设备，调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">打开并获得设备句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">调用操作码为</font><font style="color:blue;">IOCTL_STORAGE_GET_DEVICE_NUMBER</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数获得磁盘物理驱动器号。</font></p>
<p><font style="color:rgb(51, 51, 51);">4． </font><font style="color:rgb(51, 51, 51);">将所有物理磁盘号存入数组返回。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">大功告成了。可能有朋友会问，</font><font style="color:red;">GetDevicePath</font><font style="color:rgb(51, 51, 51);">不是已经获得了磁盘路径么，你前面说过，这个路径不是</font><font style="color:blue;">\.\PhysicalDriveX</font><font style="color:rgb(51, 51, 51);">就是</font><font style="color:blue;">\.\X</font><font style="color:black;">:</font><font style="color:black;"> </font><font style="color:black;">，那我们解析一下这个字符串不就可以获得磁盘号或者盘符了么。很可惜，这里的磁盘路径出现了第三种形式，而且是毫无章法的形式。打开函数</font><font style="color:red;">GetDevicePath</font><font style="color:rgb(51, 51, 51);">中的注释行</font><font style="color:rgb(51, 51, 51);">&#x2F;&#x2F;printf(“%s\n”, pDetail-&gt;DevicePath);</font><font style="color:rgb(51, 51, 51);">将这种形式的路径打印出来，可以看到类似为</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">\\?\ide#diskwdc_wd1600aajs-08b4a0___________________01.03a01#5&amp;245a6b6d&amp;0&amp;0.0.0#<br>&#123;53f56307-b6bf-11d0-94f2-00a0c91efb8b&#125;<br>\\?\ide#diskwdc_wd1600aajs-08b4a0___________________01.03a01#5&amp;37141c12&amp;0&amp;0.1.0#<br>&#123;53f56307-b6bf-11d0-94f2-00a0c91efb8b&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">所以，没办法，我们还是得用</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">找出磁盘号。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<hr>
<h1 id="八、格式化分区的思考"><a href="#八、格式化分区的思考" class="headerlink" title="八、格式化分区的思考"></a><font style="color:rgb(23, 35, 63);">八、格式化分区的思考</font></h1><p><font style="color:rgb(23, 35, 63);">格式化分区平常在我们看来是再普通不过的操作了，点两下鼠标就可以搞定的事情，但是在程序中实现的的确确不太容易。可能有人说直接调个format命令不就好了，没错，但系统命令存在我们第一节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624027">http://cutebunny.blog.51cto.com/301216/624027</a><font style="color:rgb(23, 35, 63);">中阐述的种种问题。</font></p>
<p><font style="color:rgb(51, 51, 51);">算上</font><font style="color:rgb(51, 51, 51);">format</font><font style="color:rgb(51, 51, 51);">命令，目前我发现有三种方法，</font></p>
<h3 id="1．Windows-API-SHFormatDrive"><a href="#1．Windows-API-SHFormatDrive" class="headerlink" title="1．Windows API SHFormatDrive"></a><font style="color:rgb(51, 51, 51);">1．Windows API </font><font style="color:red;">SHFormatDrive</font></h3><p><font style="color:rgb(51, 51, 51);">函数原型如下</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">SHFormatDrive</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HWND hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT drive,</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT fmtID,</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT options</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">参数</font><font style="color:blue;">drive</font><font style="color:rgb(51, 51, 51);">就是需要格式化的分区，从</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">开始计数。</font><font style="color:rgb(51, 51, 51);">0</font><font style="color:rgb(51, 51, 51);">代表</font><font style="color:rgb(51, 51, 51);">A:</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);">2</font><font style="color:rgb(51, 51, 51);">代表</font><font style="color:rgb(51, 51, 51);">C:</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">等等。其余参数详见</font><font style="color:rgb(51, 51, 51);">MSDN</font><font style="color:rgb(51, 51, 51);">。调用这个函数回弹出我们非常熟悉的对话框，相信我们右键格式化调用的就是它。</font></p>
<p><font style="color:rgb(23, 35, 63);">调用方法很简单：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SHFormatDrive</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, SHFMT_ID_DEFAULT, SHFMT_OPT_FULL);<br></code></pre></td></tr></table></figure>

<p><img src="/2024/04/10/Win32_Api/%E3%80%90NOTE%E3%80%91Windows%E7%9A%84%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C/image-1.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(51, 51, 51);">不幸的是，这个API无法让格式化自动开始，无论如何都不可以，必须手动去点一下“开始”。郁闷了吧，有人建议可以搞个定时器，再去模拟一下Enter，等格式化完了再Enter一次。原理上可行，但总觉着有些不伦不类。</font></p>
<h3 id="2．利用FMIFS-dll中的未公开函数FormatEx"><a href="#2．利用FMIFS-dll中的未公开函数FormatEx" class="headerlink" title="2．利用FMIFS.dll中的未公开函数FormatEx"></a><font style="color:rgb(51, 51, 51);">2．利用FMIFS.dll中的未公开函数</font><font style="color:red;">FormatEx</font></h3><p><font style="color:rgb(51, 51, 51);">有位叫</font><font style="color:rgb(51, 51, 51);">Mark Russinovich</font><font style="color:rgb(51, 51, 51);">的大牛写出了具体代码，我暂时还没花时间去调，仅供大家参考。代码详见附件。</font></p>
<p><font style="color:rgb(51, 51, 51);">有人好像做成功了，具体请参考</font><a target="_blank" rel="noopener" href="http://forum.sysinternals.com/creating-partitions-on-xp_topic3029.html">http://forum.sysinternals.com/creating-partitions-on-xp_topic3029.html</a></p>
<h3 id="3．Format命令"><a href="#3．Format命令" class="headerlink" title="3．Format命令"></a><font style="color:rgb(51, 51, 51);">3．Format命令</font></h3><p><font style="color:rgb(51, 51, 51);">这是没办法中的办法了，代码如下，很简单，不多解释。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function:</span><br><span class="hljs-comment">* input: disk, disk name</span><br><span class="hljs-comment">* output: N/A</span><br><span class="hljs-comment">* return: Succeed, 0</span><br><span class="hljs-comment">*         Fail, 1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">FormatVolume</span><span class="hljs-params">(CHAR letter)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD ret;<br>    CHAR cmd[<span class="hljs-number">64</span>];<br>    <span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">&quot;format %c: /FS:NTFS /Q /Y&quot;</span>, letter);<br>    ret = (DWORD)<span class="hljs-built_in">system</span>(cmd);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font style="color:rgb(51, 51, 51);">总结</font></h3><p><font style="color:rgb(51, 51, 51);">关于</font><font style="color:rgb(51, 51, 51);">windows</font><font style="color:rgb(51, 51, 51);">下磁盘操作编程的讨论到这里就告一段落了，最后再总结一下我们前面列举的所有例子。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">GetAllPresentDisks</span><span class="hljs-params">(DWORD **disks)</span></span>;        <span class="hljs-comment">//查询系统下的所有物理磁盘号</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetSystemDiskPhysicalNumber</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;        <span class="hljs-comment">//获取操作系统所在的物理磁盘号</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetPhysicalDriveFromPartitionLetter</span><span class="hljs-params">(CHAR letter)</span></span>;    <span class="hljs-comment">//根据逻辑分区号查询物理磁盘号</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetDriveGeometry</span><span class="hljs-params">(<span class="hljs-type">const</span> CHAR *disk, DISK_GEOMETRY *pdg)</span></span>;    <span class="hljs-comment">//查询磁盘物理信息</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetDiskDriveLayout</span><span class="hljs-params">(<span class="hljs-type">const</span> CHAR *disk, DRIVE_LAYOUT_INFORMATION_EX *driveLayout)</span></span>;          <span class="hljs-comment">//查询磁盘分区信息</span><br><span class="hljs-function">DWORD <span class="hljs-title">DestroyDisk</span><span class="hljs-params">(DWORD disk)</span></span>;        <span class="hljs-comment">//删除磁盘分区表</span><br><span class="hljs-function">DWORD <span class="hljs-title">CreateDisk</span><span class="hljs-params">(DWORD disk, WORD partNum)</span></span>;     <span class="hljs-comment">//初始化磁盘并创建分区</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetPartitionLetterFromPhysicalDrive</span><span class="hljs-params">(DWORD pDriveNumber, CHAR **letters)</span></span>;     <span class="hljs-comment">//查询某块物理磁盘上的所有分区</span><br><span class="hljs-function">DWORD <span class="hljs-title">FormatVolume</span><span class="hljs-params">(CHAR letter)</span></span>; <span class="hljs-comment">//格式化分区</span><br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">上述函数有些相当危险，可能瞬间就破坏掉磁盘分区表，大家调试的时候请多加小心。当然，也不要用它来做坏事哦。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<hr>
<h1 id="九、区分本地磁盘与移动硬盘"><a href="#九、区分本地磁盘与移动硬盘" class="headerlink" title="九、区分本地磁盘与移动硬盘"></a><font style="color:rgb(23, 35, 63);">九、区分本地磁盘与移动硬盘</font></h1><p><font style="color:rgb(23, 35, 63);">最近碰到了个新问题，记录下来作为windows的磁盘操作那个系列的续篇吧。</font></p>
<p><font style="color:rgb(51, 51, 51);">一些时候我们的程序需要区分本地存储设备和</font><font style="color:rgb(51, 51, 51);">USB</font><font style="color:rgb(51, 51, 51);">存储设备。在网上搜一搜一般会找到一个最直接的</font><font style="color:rgb(51, 51, 51);">API</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:red;">GetDriveType</font><font style="color:rgb(51, 51, 51);">，其原型为</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">UINT <span class="hljs-title">GetDriveType</span><span class="hljs-params">(LPCTSTR lpRootPathName)</span></span><br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">参数</font><font style="color:blue;">lpRootPathName</font><font style="color:rgb(51, 51, 51);">是存储设备的根目录，例如</font>C:\，返回值即为设备类型。</p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:black;">Return code</font></strong></th>
<th align="left"><strong><font style="color:black;">Description</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">DRIVE_REMOVABLE</font></td>
<td align="left"><font style="color:black;">The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">DRIVE_FIXED</font></td>
<td align="left"><font style="color:black;">The drive has fixed media; for example, a hard drive or flash drive.</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(51, 51, 51);">或者采用一种稍微复杂一点的方法，使用我们第一节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/624027">http://cutebunny.blog.51cto.com/301216/624027</a><font style="color:rgb(51, 51, 51);">中介绍的</font><font style="color:red;">GetDriveGeometry()</font><font style="color:rgb(51, 51, 51);">函数，其输出参数</font><font style="color:blue;">DISK_GEOMETRY *pdg</font><font style="color:rgb(51, 51, 51);">中的</font><font style="color:blue;">MediaType</font><font style="color:rgb(51, 51, 51);">字段代表设备类型。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_MEDIA_TYPE</span><br>&#123;<br>    …<br>    RemovableMedia<br>    FixedMedia<br>    …<br>&#125;MEDIA_TYPE;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">这两个方法看似能方便快捷的解决我们的需求，但事实上当你使用</font><font style="color:red;">GetDriveType()</font><font style="color:rgb(51, 51, 51);">去获取一块移动硬盘的类型时，程序会坑爹的告诉你这块移动硬盘的类型是</font><font style="color:blue;">DRIVE_FIXED</font><font style="color:rgb(51, 51, 51);">，根本无法与本地磁盘区分开来。</font><font style="color:red;">GetDriveGeometry()</font><font style="color:rgb(51, 51, 51);">函数的结果也是如此。</font></p>
<p><font style="color:rgb(51, 51, 51);">事实上，上述方法只对小容量的</font><font style="color:rgb(51, 51, 51);">U</font><font style="color:rgb(51, 51, 51);">盘有效，会返回给你</font><font style="color:blue;">DRIVE_REMOVABLE</font><font style="color:rgb(51, 51, 51);">的结果；而对移动硬盘甚至是一块稍大容量的</font><font style="color:rgb(51, 51, 51);">U</font><font style="color:rgb(51, 51, 51);">盘（比如我有一块格式化为</font><font style="color:rgb(51, 51, 51);">FAT32</font><font style="color:rgb(51, 51, 51);">格式的</font><font style="color:rgb(51, 51, 51);">4G U</font><font style="color:rgb(51, 51, 51);">盘），就无能为力了。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">所以，我们必须采用别的思路了，这里我介绍一种通过查看总线类型来区分本地磁盘和</font><font style="color:rgb(51, 51, 51);">USB</font><font style="color:rgb(51, 51, 51);">磁盘的方法。当然，其基础还是我们那万能的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">，不过这次的控制码为</font><font style="color:blue;">IOCTL_STORAGE_QUERY_PROPERTY</font><font style="color:rgb(51, 51, 51);">。同时对应的输入参数为</font><font style="color:blue;">STORAGE_PROPERTY_QUERY</font><font style="color:rgb(51, 51, 51);">结构，输出参数为</font><font style="color:blue;">STORAGE_DEVICE_DESCRIPTOR</font><font style="color:rgb(51, 51, 51);">结构体。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_STORAGE_PROPERTY_QUERY</span> &#123;<br>    STORAGE_PROPERTY_ID  PropertyId;<br>    STORAGE_QUERY_TYPE  QueryType;<br>    UCHAR  AdditionalParameters[<span class="hljs-number">1</span>];<br>&#125; STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">调用时需设置输入参数中的字段</font></p>
<p><font style="color:rgb(51, 51, 51);">PropertyId &#x3D; StorageDeviceProperty;</font></p>
<p><font style="color:rgb(51, 51, 51);">QueryType &#x3D; PropertyStandardQuery;</font></p>
<p><font style="color:rgb(51, 51, 51);">以表明我们要查询一个</font><font style="color:rgb(51, 51, 51);">device descriptor</font><font style="color:rgb(51, 51, 51);">，也就是说，只有指定这种类型，输出参数才会得到</font><font style="color:blue;">STORAGE_DEVICE_DESCRIPTOR</font><font style="color:rgb(51, 51, 51);">类型数据。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_STORAGE_DEVICE_DESCRIPTOR</span> &#123;<br>    ULONG  Version;<br>    ULONG  Size;<br>    UCHAR  DeviceType;<br>    UCHAR  DeviceTypeModifier;<br>    BOOLEAN  RemovableMedia;<br>    BOOLEAN  CommandQueueing;<br>    ULONG  VendorIdOffset;<br>    ULONG  ProductIdOffset;<br>    ULONG  ProductRevisionOffset;<br>    ULONG  SerialNumberOffset;<br>    STORAGE_BUS_TYPE  BusType;<br>    ULONG  RawPropertiesLength;<br>    UCHAR  RawDeviceProperties[<span class="hljs-number">1</span>];<br>&#125; STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">其中，</font><font style="color:blue;">BusType</font><font style="color:rgb(51, 51, 51);">定义为</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_STORAGE_BUS_TYPE</span> &#123;<br>    BusTypeUnknown = <span class="hljs-number">0x00</span>,<br>    BusTypeScsi,<br>    BusTypeAtapi,<br>    BusTypeAta,<br>    BusType1394,<br>    BusTypeSsa,<br>    BusTypeFibre,<br>    BusTypeUsb,<br>    BusTypeRAID,<br>    BusTypeiScsi,<br>    BusTypeSas,<br>    BusTypeSata,<br>    BusTypeSd,<br>    BusTypeMmc,<br>    BusTypeMax,<br>    BusTypeMaxReserved = <span class="hljs-number">0x7F</span><br>&#125; STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">明白了吧，如果总线类型为</font><font style="color:blue;">BusTypeUsb</font><font style="color:rgb(51, 51, 51);">，就是找到了我们的</font><font style="color:rgb(51, 51, 51);">USB</font><font style="color:rgb(51, 51, 51);">移动硬盘了。</font></p>
<p><font style="color:rgb(51, 51, 51);">但此时还需要解决一个问题，</font><font style="color:blue;">STORAGE_DEVICE_DESCRIPTOR</font><font style="color:rgb(51, 51, 51);">可以理解为一个变长缓冲区，最后一个字段</font><font style="color:blue;">RawDeviceProperties[1]</font><font style="color:rgb(51, 51, 51);">是可以动态扩展的（</font><font style="color:rgb(51, 51, 51);">windows API</font><font style="color:rgb(51, 51, 51);">经常有这种情况）</font><font style="color:rgb(51, 51, 51);">，那么函数</font><font style="color:red;">DeviceIoControl()</font><font style="color:rgb(51, 51, 51);">中的参数</font><font style="color:rgb(51, 51, 51);">nOutBufferSize</font><font style="color:rgb(51, 51, 51);">应该填多少呢？这时我们需要借助另一个数据结构</font><font style="color:blue;">STORAGE_DESCRIPTOR_HEADER</font><font style="color:rgb(51, 51, 51);">，在我们不知道</font><font style="color:rgb(51, 51, 51);">device descriptor</font><font style="color:rgb(51, 51, 51);">实际需要多大的缓冲区时，可以先把</font><font style="color:blue;">STORAGE_DESCRIPTOR_HEADER</font><font style="color:rgb(51, 51, 51);">作为输出参数以获得</font><font style="color:rgb(51, 51, 51);">device descriptor</font><font style="color:rgb(51, 51, 51);">的缓冲区大小，其大小被存入</font><font style="color:rgb(51, 51, 51);">header</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:blue;">size</font><font style="color:rgb(51, 51, 51);">字段中。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_STORAGE_DESCRIPTOR_HEADER</span> &#123;<br>    ULONG  Version;<br>    ULONG  Size;<br>&#125; STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;<br></code></pre></td></tr></table></figure>

<h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a><font style="color:rgb(51, 51, 51);">具体代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment">* Function: get the bus type of an disk</span><br><span class="hljs-comment">* input: drive name (c:)</span><br><span class="hljs-comment">* output: bus type</span><br><span class="hljs-comment">* return: Succeed, 0</span><br><span class="hljs-comment">*         Fail, -1</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-function">DWORD <span class="hljs-title">GetDriveTypeByBus</span><span class="hljs-params">(<span class="hljs-type">const</span> CHAR *drive, WORD *type)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hDevice;               <span class="hljs-comment">// handle to the drive to be examined</span><br>    BOOL result;                 <span class="hljs-comment">// results flag</span><br>    DWORD readed;                   <span class="hljs-comment">// discard results</span><br> <br>    STORAGE_DESCRIPTOR_HEADER *pDevDescHeader;<br>    STORAGE_DEVICE_DESCRIPTOR *pDevDesc;<br>    DWORD devDescLength;<br>    STORAGE_PROPERTY_QUERY query;<br> <br>    hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                    drive, <span class="hljs-comment">// drive to open</span><br>                    GENERIC_READ | GENERIC_WRITE,     <span class="hljs-comment">// access to the drive</span><br>                    FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-comment">//share mode</span><br>                    <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                    OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                    <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                    <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// do not copy file attribute</span><br>                    );<br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="hljs-comment">// cannot open the drive</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    query.PropertyId = StorageDeviceProperty;<br>    query.QueryType = PropertyStandardQuery;<br> <br>    pDevDescHeader = (STORAGE_DESCRIPTOR_HEADER *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(STORAGE_DESCRIPTOR_HEADER));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pDevDescHeader)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br>   <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                    hDevice,     <span class="hljs-comment">// device to be queried</span><br>                    IOCTL_STORAGE_QUERY_PROPERTY,     <span class="hljs-comment">// operation to perform</span><br>                    &amp;query,<br>                    <span class="hljs-keyword">sizeof</span> query,               <span class="hljs-comment">// no input buffer</span><br>                    pDevDescHeader,<br>                    <span class="hljs-built_in">sizeof</span>(STORAGE_DESCRIPTOR_HEADER),     <span class="hljs-comment">// output buffer</span><br>                    &amp;readed,                 <span class="hljs-comment">// # bytes returned</span><br>                    <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">// synchronous I/O</span><br>    <span class="hljs-keyword">if</span> (!result)        <span class="hljs-comment">//fail</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_STORAGE_QUERY_PROPERTY Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-built_in">free</span>(pDevDescHeader);<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    devDescLength = pDevDescHeader-&gt;Size;<br>    pDevDesc = (STORAGE_DEVICE_DESCRIPTOR *)<span class="hljs-built_in">malloc</span>(devDescLength);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pDevDesc)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pDevDescHeader);<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                    hDevice,     <span class="hljs-comment">// device to be queried</span><br>                    IOCTL_STORAGE_QUERY_PROPERTY,     <span class="hljs-comment">// operation to perform</span><br>                    &amp;query,<br>                    <span class="hljs-keyword">sizeof</span> query,               <span class="hljs-comment">// no input buffer</span><br>                    pDevDesc,<br>                    devDescLength,     <span class="hljs-comment">// output buffer</span><br>                    &amp;readed,                 <span class="hljs-comment">// # bytes returned</span><br>                    <span class="hljs-literal">NULL</span>);      <span class="hljs-comment">// synchronous I/O</span><br>    <span class="hljs-keyword">if</span> (!result)        <span class="hljs-comment">//fail</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;IOCTL_STORAGE_QUERY_PROPERTY Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-built_in">free</span>(pDevDescHeader);<br>        <span class="hljs-built_in">free</span>(pDevDesc);<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DWORD</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;, pDevDesc-&gt;BusType);</span><br>    *type = (WORD)pDevDesc-&gt;BusType;<br>    <span class="hljs-built_in">free</span>(pDevDescHeader);<br>    <span class="hljs-built_in">free</span>(pDevDesc);<br> <br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a><font style="color:rgb(51, 51, 51);">代码说明</font></h3><p><font style="color:rgb(51, 51, 51);">1． </font><font style="color:rgb(51, 51, 51);">调用</font><font style="color:red;">CreateFile</font><font style="color:rgb(51, 51, 51);">打开并获得设备句柄。</font></p>
<p><font style="color:rgb(51, 51, 51);">2． </font><font style="color:rgb(51, 51, 51);">在输入参数</font><font style="color:blue;">STORAGE_PROPERTY_QUERY query</font><font style="color:rgb(51, 51, 51);">中指定查询类型。</font></p>
<p><font style="color:rgb(51, 51, 51);">3． </font><font style="color:rgb(51, 51, 51);">以</font><font style="color:blue;">STORAGE_DESCRIPTOR_HEADER *pDevDescHeader</font><font style="color:rgb(51, 51, 51);">为输出参数，调用操作码为</font><font style="color:blue;">IOCTL_STORAGE_QUERY_PROPERTY</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数获得输出缓冲区大小。</font></p>
<p><font style="color:rgb(51, 51, 51);">4． </font><font style="color:rgb(51, 51, 51);">按</font><font style="color:rgb(51, 51, 51);">3</font><font style="color:rgb(51, 51, 51);">中获得的缓冲区大小为</font><font style="color:blue;">STORAGE_DEVICE_DESCRIPTOR *pDevDesc</font><font style="color:rgb(51, 51, 51);">分配空间，以</font><font style="color:blue;">pDevDesc</font><font style="color:rgb(51, 51, 51);">为输出参数，调用操作码为</font><font style="color:blue;">IOCTL_STORAGE_QUERY_PROPERTY</font><font style="color:rgb(51, 51, 51);">的</font><font style="color:red;">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">函数获得</font><font style="color:rgb(51, 51, 51);">device descriptor</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);">5． </font><font style="color:rgb(51, 51, 51);">从</font><font style="color:rgb(51, 51, 51);">device descriptor</font><font style="color:rgb(51, 51, 51);">中获得</font><font style="color:blue;">BusType</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<hr>
<h1 id="十、获取磁盘型号"><a href="#十、获取磁盘型号" class="headerlink" title="十、获取磁盘型号"></a><font style="color:rgb(23, 35, 63);">十、获取磁盘型号</font></h1><p><font style="color:rgb(23, 35, 63);">我们在第七节</font><a target="_blank" rel="noopener" href="http://cutebunny.blog.51cto.com/301216/625577">http://cutebunny.blog.51cto.com/301216/625577</a><font style="color:rgb(23, 35, 63);">中探讨了如何获取系统中所有磁盘的磁盘号。但是在很多情况下，仅仅是磁盘号并不能满足我们的需求，我们希望在应用程序界面上显示更详细的磁盘信息。通过前面几节的方法，我们已经可以获得许多磁盘信息，例如磁盘大小，柱面，扇区，分区等等。但是如下图所示，我们在设备管理器中看到的“WDC WD1600AAJS-08B4A0”这种更为人性化的磁盘类型描述，至今为止我们还没有办法获得。本节就来解决这个问题。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">提前声明，本节涉及一些</font><font style="color:rgb(51, 51, 51);">ATA&#x2F;APAPI</font><font style="color:rgb(51, 51, 51);">内容，我本人理解的不是十分透彻，在网上搜集了很多相关资料才调通了后面示例中的代码。如有不正确之处欢迎大家指教。</font></p>
<p><font style="color:rgb(51, 51, 51);">对于类似于“WDC WD1600AAJS-08B4A0”的磁盘型号描述，下文中称为</font><strong><font style="color:rgb(51, 51, 51);">model number</font></strong><font style="color:rgb(51, 51, 51);">，微软在VC&#x2F;MFC环境中没有开放获取的方法。所以我们要用到ATA&#x2F;APAPI的IDENTIFY DEVICE指令。ATA&#x2F;APAPI是国际组织T13起草和发布的IDE&#x2F;EIDE&#x2F;UDMA硬盘及其它可移动存储设备与主机接口的标准，至今已经到了ATA&#x2F;APAPI-7版本。该接口标准规定了ATA&#x2F;ATAPI设备的输入输出寄存器和指令集。</font></p>
<p><font style="color:rgb(51, 51, 51);">首先介绍几个新的</font><font style="color:rgb(51, 51, 51);">DeviceIoControl</font><font style="color:rgb(51, 51, 51);">的控制码和相关数据结构。</font></p>
<h3 id="1-控制码SMART-GET-VERSION"><a href="#1-控制码SMART-GET-VERSION" class="headerlink" title="1. 控制码SMART_GET_VERSION"></a><font style="color:rgb(51, 51, 51);">1. 控制码SMART_GET_VERSION</font></h3><p><font style="color:rgb(51, 51, 51);">控制码</font><font style="color:rgb(51, 51, 51);">SMART_GET_VERSION</font><font style="color:rgb(51, 51, 51);">在</font><font style="color:rgb(51, 51, 51);">MSDN</font><font style="color:rgb(51, 51, 51);">中的描述如下，</font></p>
<p><strong><font style="color:black;">Operation</font></strong></p>
<p><font style="color:black;">Returns version information, a capabilities mask, and a bitmask for the device. This IOCTL must be handled by drivers that support Self-Monitoring Analysis and Reporting Technology (SMART).</font></p>
<p><font style="color:rgb(51, 51, 51);">好，我们要的就是这个</font><font style="color:rgb(51, 51, 51);">bitmask</font><font style="color:rgb(51, 51, 51);">，它是我们后面完成任务的关键参数。</font></p>
<p><font style="color:rgb(51, 51, 51);">而这个bitmask是结构体</font><strong><font style="color:rgb(51, 51, 51);">GETVERSIONINPARAMS</font></strong><font style="color:rgb(51, 51, 51);">的成员，此结构体是作为控制码为</font><strong><font style="color:rgb(51, 51, 51);">SMART_GET_VERSION</font></strong><font style="color:rgb(51, 51, 51);">的</font><font style="color:#DF2A3F;">DeviceIoControl()</font><font style="color:rgb(51, 51, 51);">函数的输出参数的。</font></p>
<p><font style="color:rgb(51, 51, 51);">定义如下：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_GETVERSIONINPARAMS</span> &#123;<br>    UCHAR  bVersion;<br>    UCHAR  bRevision;<br>    UCHAR  bReserved;<br>    UCHAR  bIDEDeviceMap;<br>    ULONG  fCapabilities;<br>    ULONG  dwReserved[<span class="hljs-number">4</span>];<br>&#125; GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;<br></code></pre></td></tr></table></figure>

<p>其中UCHAR  bIDEDeviceMap就是我们所要的bitmask，具体定义为</p>
<p><code>bIDEDeviceMap</code></p>
<p>包含位图。 下表说明了位图的含义：</p>
<p><strong>展开表</strong></p>
<table>
<thead>
<tr>
<th align="left"><font style="color:rgb(22, 22, 22);">位图标志</font></th>
<th align="left"><font style="color:rgb(22, 22, 22);">意义</font></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 0 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 SATA 驱动器或 IDE 驱动器。 如果它是 IDE 驱动器，则它是主通道上的主设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 1 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 IDE 驱动器，它是主通道上的从属设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 2 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 IDE 驱动器，它是辅助通道上的主设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 3 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 IDE 驱动器，它是辅助通道上的从属设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 4 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 ATAPI 驱动器，它是主通道上的主设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 5 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 ATAPI 驱动器，它是主通道上的从属设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 6 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 ATAPI 驱动器，它是辅助通道上的主设备。</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(22, 22, 22);">位 7 设置为 1。</font></td>
<td align="left"><font style="color:rgb(22, 22, 22);">设备是 ATAPI 驱动器，它是辅助通道上的从属设备。</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(51, 51, 51);">从这里可以看出，这个关键的参数事实上表明了驱动器类型和所在的</font><font style="color:rgb(51, 51, 51);">channel</font><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<h3 id="2-控制码SMART-RCV-DRIVE-DATA"><a href="#2-控制码SMART-RCV-DRIVE-DATA" class="headerlink" title="2. 控制码SMART_RCV_DRIVE_DATA"></a><font style="color:rgb(51, 51, 51);">2. 控制码SMART_RCV_DRIVE_DATA</font></h3><p><font style="color:rgb(51, 51, 51);">使用控制码</font><strong><font style="color:rgb(51, 51, 51);">SMART_RCV_DRIVE_DATA</font></strong><font style="color:rgb(51, 51, 51);">的</font><font style="color:#DF2A3F;">DeviceIoControl()</font><font style="color:rgb(51, 51, 51);">函数的输入输出参数分别为</font><strong><font style="color:rgb(51, 51, 51);">SENDCMDINPARAMS</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(51, 51, 51);">SENDCMDOUTPARAMS</font></strong><font style="color:rgb(51, 51, 51);">。我们在输入参数SENDCMDINPARAMS中填入合适的信息，包括刚才那个关键的bitmask，就能在输出参数SENDCMDOUTPARAMS中拿到我们需要的model number。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">SENDCMDOUTPARAMS</font></strong><font style="color:rgb(51, 51, 51);">结构定义如下，</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_SENDCMDOUTPARAMS</span> &#123;<br>    ULONG  cBufferSize;<br>    DRIVERSTATUS  DriverStatus;<br>    UCHAR  bBuffer[<span class="hljs-number">1</span>];<br>&#125; SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">model number</font><font style="color:rgb(51, 51, 51);">就存在于</font><font style="color:rgb(51, 51, 51);">bBuffer</font><font style="color:rgb(51, 51, 51);">中，</font><font style="color:rgb(51, 51, 51);">bBuffer</font><font style="color:rgb(51, 51, 51);">的格式需要依据</font><font style="color:rgb(51, 51, 51);">ATA&#x2F;ATAPI</font><font style="color:rgb(51, 51, 51);">中的定义解析：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IDINFO</span><br>&#123;<br>    USHORT  wGenConfig;     <span class="hljs-comment">// WORD 0: 基本信息字</span><br>    USHORT  wNumCyls;     <span class="hljs-comment">// WORD 1: 柱面数</span><br>    USHORT  wReserved2;     <span class="hljs-comment">// WORD 2: 保留</span><br>    USHORT  wNumHeads;     <span class="hljs-comment">// WORD 3: 磁头数</span><br>    USHORT  wReserved4;        <span class="hljs-comment">// WORD 4: 保留</span><br>    USHORT  wReserved5;        <span class="hljs-comment">// WORD 5: 保留</span><br>    USHORT  wNumSectorsPerTrack;  <span class="hljs-comment">// WORD 6: 每磁道扇区数</span><br>    USHORT  wVendorUnique[<span class="hljs-number">3</span>];   <span class="hljs-comment">// WORD 7-9: 厂家设定值</span><br>    CHAR    sSerialNumber[<span class="hljs-number">20</span>];   <span class="hljs-comment">// WORD 10-19:序列号</span><br>    USHORT  wBufferType;    <span class="hljs-comment">// WORD 20: 缓冲类型</span><br>    USHORT  wBufferSize;    <span class="hljs-comment">// WORD 21: 缓冲大小</span><br>    USHORT  wECCSize;     <span class="hljs-comment">// WORD 22: ECC校验大小</span><br>    CHAR    sFirmwareRev[<span class="hljs-number">8</span>];   <span class="hljs-comment">// WORD 23-26: 固件版本</span><br>    CHAR    sModelNumber[<span class="hljs-number">40</span>];   <span class="hljs-comment">// WORD 27-46: 内部型号</span><br>    USHORT  wMoreVendorUnique;   <span class="hljs-comment">// WORD 47: 厂家设定值</span><br>    USHORT  wReserved48;    <span class="hljs-comment">// WORD 48: 保留</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  reserved1:<span class="hljs-number">8</span>;<br>        USHORT  DMA:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持DMA</span><br>        USHORT  LBA:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持LBA</span><br>        USHORT  DisIORDY:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=可不使用IORDY</span><br>        USHORT  IORDY:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持IORDY</span><br>        USHORT  SoftReset:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 1=需要ATA软启动</span><br>        USHORT  Overlap:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持重叠操作</span><br>        USHORT  Queue:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持命令队列</span><br>        USHORT  InlDMA:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持交叉存取DMA</span><br>    &#125; wCapabilities;     <span class="hljs-comment">// WORD 49: 一般能力</span><br>    USHORT  wReserved1;     <span class="hljs-comment">// WORD 50: 保留</span><br>    USHORT  wPIOTiming;     <span class="hljs-comment">// WORD 51: PIO时序</span><br>    USHORT  wDMATiming;     <span class="hljs-comment">// WORD 52: DMA时序</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  CHSNumber:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 1=WORD 54-58有效</span><br>        USHORT  CycleNumber:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 1=WORD 64-70有效</span><br>        USHORT  UnltraDMA:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 1=WORD 88有效</span><br>        USHORT  reserved:<span class="hljs-number">13</span>;<br>    &#125; wFieldValidity;     <span class="hljs-comment">// WORD 53: 后续字段有效性标志</span><br>    USHORT  wNumCurCyls;    <span class="hljs-comment">// WORD 54: CHS可寻址的柱面数</span><br>    USHORT  wNumCurHeads;    <span class="hljs-comment">// WORD 55: CHS可寻址的磁头数</span><br>    USHORT  wNumCurSectorsPerTrack;  <span class="hljs-comment">// WORD 56: CHS可寻址每磁道扇区数</span><br>    USHORT  wCurSectorsLow;    <span class="hljs-comment">// WORD 57: CHS可寻址的扇区数低位字</span><br>    USHORT  wCurSectorsHigh;   <span class="hljs-comment">// WORD 58: CHS可寻址的扇区数高位字</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  CurNumber:<span class="hljs-number">8</span>;   <span class="hljs-comment">// 当前一次性可读写扇区数</span><br>        USHORT  Multi:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择多扇区读写</span><br>        USHORT  reserved1:<span class="hljs-number">7</span>;<br>    &#125; wMultSectorStuff;     <span class="hljs-comment">// WORD 59: 多扇区读写设定</span><br>    ULONG  dwTotalSectors;    <span class="hljs-comment">// WORD 60-61: LBA可寻址的扇区数</span><br>    USHORT  wSingleWordDMA;    <span class="hljs-comment">// WORD 62: 单字节DMA支持能力</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  Mode0:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式0 (4.17Mb/s)</span><br>        USHORT  Mode1:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式1 (13.3Mb/s)</span><br>        USHORT  Mode2:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式2 (16.7Mb/s)</span><br>        USHORT  Reserved1:<span class="hljs-number">5</span>;<br>        USHORT  Mode0Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式0</span><br>        USHORT  Mode1Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式1</span><br>        USHORT  Mode2Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式2</span><br>        USHORT  Reserved2:<span class="hljs-number">5</span>;<br>    &#125; wMultiWordDMA;     <span class="hljs-comment">// WORD 63: 多字节DMA支持能力</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  AdvPOIModes:<span class="hljs-number">8</span>;   <span class="hljs-comment">// 支持高级POI模式数</span><br>        USHORT  reserved:<span class="hljs-number">8</span>;<br>    &#125; wPIOCapacity;      <span class="hljs-comment">// WORD 64: 高级PIO支持能力</span><br>    USHORT  wMinMultiWordDMACycle;  <span class="hljs-comment">// WORD 65: 多字节DMA传输周期的最小值</span><br>    USHORT  wRecMultiWordDMACycle;  <span class="hljs-comment">// WORD 66: 多字节DMA传输周期的建议值</span><br>    USHORT  wMinPIONoFlowCycle;   <span class="hljs-comment">// WORD 67: 无流控制时PIO传输周期的最小值</span><br>    USHORT  wMinPOIFlowCycle;   <span class="hljs-comment">// WORD 68: 有流控制时PIO传输周期的最小值</span><br>    USHORT  wReserved69[<span class="hljs-number">11</span>];   <span class="hljs-comment">// WORD 69-79: 保留</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  Reserved1:<span class="hljs-number">1</span>;<br>        USHORT  ATA1:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA-1</span><br>        USHORT  ATA2:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA-2</span><br>        USHORT  ATA3:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA-3</span><br>        USHORT  ATA4:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-4</span><br>        USHORT  ATA5:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-5</span><br>        USHORT  ATA6:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-6</span><br>        USHORT  ATA7:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-7</span><br>        USHORT  ATA8:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-8</span><br>        USHORT  ATA9:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 1=支持ATA/ATAPI-9</span><br>        USHORT  ATA10:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持ATA/ATAPI-10</span><br>        USHORT  ATA11:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持ATA/ATAPI-11</span><br>        USHORT  ATA12:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持ATA/ATAPI-12</span><br>        USHORT  ATA13:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持ATA/ATAPI-13</span><br>        USHORT  ATA14:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持ATA/ATAPI-14</span><br>        USHORT  Reserved2:<span class="hljs-number">1</span>;<br>    &#125; wMajorVersion;     <span class="hljs-comment">// WORD 80: 主版本</span><br>    USHORT  wMinorVersion;    <span class="hljs-comment">// WORD 81: 副版本</span><br>    USHORT  wReserved82[<span class="hljs-number">6</span>];    <span class="hljs-comment">// WORD 82-87: 保留</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        USHORT  Mode0:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式0 (16.7Mb/s)</span><br>        USHORT  Mode1:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式1 (25Mb/s)</span><br>        USHORT  Mode2:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式2 (33Mb/s)</span><br>        USHORT  Mode3:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式3 (44Mb/s)</span><br>        USHORT  Mode4:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式4 (66Mb/s)</span><br>        USHORT  Mode5:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式5 (100Mb/s)</span><br>        USHORT  Mode6:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式6 (133Mb/s)</span><br>        USHORT  Mode7:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=支持模式7 (166Mb/s) ???</span><br>        USHORT  Mode0Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式0</span><br>        USHORT  Mode1Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式1</span><br>        USHORT  Mode2Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式2</span><br>        USHORT  Mode3Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式3</span><br>        USHORT  Mode4Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式4</span><br>        USHORT  Mode5Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式5</span><br>        USHORT  Mode6Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式6</span><br>        USHORT  Mode7Sel:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 1=已选择模式7</span><br>    &#125; wUltraDMA;      <span class="hljs-comment">// WORD 88:  Ultra DMA支持能力</span><br>    USHORT    wReserved89[<span class="hljs-number">167</span>];   <span class="hljs-comment">// WORD 89-255</span><br>&#125; IDINFO, *PIDINFO;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">由此可知，</font><font style="color:rgb(51, 51, 51);">512</font><font style="color:rgb(51, 51, 51);">字节的</font><font style="color:rgb(51, 51, 51);">bBuffer</font><font style="color:rgb(51, 51, 51);">中，</font><font style="color:rgb(51, 51, 51);">27~46</font><font style="color:rgb(51, 51, 51);">字节即为我们所需的</font><font style="color:rgb(51, 51, 51);">model number</font><font style="color:rgb(51, 51, 51);">。经过一定的字节序转换后大功告成。</font></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><font style="color:rgb(51, 51, 51);">实现代码</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> WORD IDE_ATAPI_IDENTIFY = <span class="hljs-number">0xA1</span>;   <span class="hljs-comment">// 读取ATAPI设备的命令</span><br><span class="hljs-type">const</span> WORD IDE_ATA_IDENTIFY   = <span class="hljs-number">0xEC</span>;   <span class="hljs-comment">// 读取ATA设备的命令</span><br> <br><span class="hljs-function">DWORD <span class="hljs-title">GetDiskModelNumber</span><span class="hljs-params">(DWORD driver, CHAR *modelNumber)</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR sFilePath[DISK_PATH_LEN];<br>    BOOL result;                 <span class="hljs-comment">// results flag</span><br>    DWORD readed;                   <span class="hljs-comment">// discard results</span><br>    HANDLE hDevice;<br>    WORD i;<br>   <br>    <span class="hljs-built_in">sprintf</span>(sFilePath, <span class="hljs-string">&quot;\\\\.\\PHYSICALDRIVE%d&quot;</span>, driver);<br>    <br>    hDevice = <span class="hljs-built_in">CreateFile</span>(<br>                    sFilePath, <span class="hljs-comment">// drive to open</span><br>                    GENERIC_READ | GENERIC_WRITE,     <span class="hljs-comment">// access to the drive</span><br>                    FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-comment">//share mode</span><br>                    <span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// default security attributes</span><br>                    OPEN_EXISTING,    <span class="hljs-comment">// disposition</span><br>                    <span class="hljs-number">0</span>,                <span class="hljs-comment">// file attributes</span><br>                    <span class="hljs-literal">NULL</span>            <span class="hljs-comment">// do not copy file attribute</span><br>                    );<br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;CreateFile() Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    GETVERSIONINPARAMS gvopVersionParams;<br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                    hDevice,<br>                                   SMART_GET_VERSION,<br>                                   <span class="hljs-literal">NULL</span>,<br>                                   <span class="hljs-number">0</span>,<br>                                   &amp;gvopVersionParams,<br>                                   <span class="hljs-built_in">sizeof</span>(gvopVersionParams),<br>                                   &amp;readed,<br>                                   <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!result)        <span class="hljs-comment">//fail</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;SMART_GET_VERSION Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == gvopVersionParams.bIDEDeviceMap)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// IDE or ATAPI IDENTIFY cmd</span><br>    BYTE btIDCmd;<br>    SENDCMDINPARAMS inParams;<br>    BYTE nDrive =<span class="hljs-number">0</span>;<br>    btIDCmd = (gvopVersionParams.bIDEDeviceMap &gt;&gt; nDrive &amp; <span class="hljs-number">0x10</span>) ? IDE_ATAPI_IDENTIFY : IDE_ATA_IDENTIFY;<br> <br>    <span class="hljs-comment">// output structure</span><br>    BYTE outParams[<span class="hljs-built_in">sizeof</span>(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - <span class="hljs-number">1</span>];   <span class="hljs-comment">// + 512 - 1</span><br> <br>    <span class="hljs-comment">//fill in the input buffer</span><br>    inParams.cBufferSize = <span class="hljs-number">0</span>;           <span class="hljs-comment">//or IDENTIFY_BUFFER_SIZE ?</span><br>    inParams.irDriveRegs.bFeaturesReg = READ_ATTRIBUTES;<br>    inParams.irDriveRegs.bSectorCountReg = <span class="hljs-number">1</span>;<br>    inParams.irDriveRegs.bSectorNumberReg = <span class="hljs-number">1</span>;<br>    inParams.irDriveRegs.bCylLowReg = <span class="hljs-number">0</span>;<br>    inParams.irDriveRegs.bCylHighReg = <span class="hljs-number">0</span>;<br> <br>    inParams.irDriveRegs.bDriveHeadReg = (nDrive &amp; <span class="hljs-number">1</span>) ? <span class="hljs-number">0xB0</span> : <span class="hljs-number">0xA0</span>;<br>    inParams.irDriveRegs.bCommandReg = btIDCmd;<br>    <span class="hljs-comment">//inParams.bDriveNumber = nDrive;</span><br> <br>    <span class="hljs-comment">//get the attributes</span><br>    result = <span class="hljs-built_in">DeviceIoControl</span>(<br>                    hDevice,<br>                    SMART_RCV_DRIVE_DATA,<br>                    &amp;inParams,<br>                    <span class="hljs-built_in">sizeof</span>(SENDCMDINPARAMS) - <span class="hljs-number">1</span>,<br>                    outParams,<br>                    <span class="hljs-built_in">sizeof</span>(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - <span class="hljs-number">1</span>,<br>                    &amp;readed,<br>                    <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!result)        <span class="hljs-comment">//fail</span><br>    &#123;<br>       <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;SMART_RCV_DRIVE_DATA Error: %ld\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>       (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br>       <span class="hljs-keyword">return</span> (DWORD)<span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">CloseHandle</span>(hDevice);<br> <br>    DWORD dwDiskData[IDENTIFY_BUFFER_SIZE / <span class="hljs-number">2</span>];<br>    WORD *pIDSector; <span class="hljs-comment">// 对应结构IDSECTOR，见头文件</span><br>    pIDSector = (WORD *)(((SENDCMDOUTPARAMS*)outParams)-&gt;bBuffer);      <span class="hljs-comment">//lint !e826</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; IDENTIFY_BUFFER_SIZE / <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        dwDiskData[i] = pIDSector[i];       <span class="hljs-comment">//lint !e662 !e661</span><br>    &#125;<br> <br>    <span class="hljs-comment">// get model number</span><br>    <span class="hljs-built_in">memset</span>(modelNumber, <span class="hljs-number">0</span>, DISK_INFO_BUF_LEN);<br>    <span class="hljs-built_in">strcpy</span>(modelNumber, <span class="hljs-built_in">ConvertSENDCMDOUTPARAMSBufferToString</span>(dwDiskData, <span class="hljs-number">27</span>, <span class="hljs-number">46</span>));<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a><font style="color:rgb(51, 51, 51);">代码分析</font></h3><ol>
<li><font style="color:rgb(51, 51, 51);">老套路，通过CreateFile()打开设备。</font></li>
<li><font style="color:rgb(51, 51, 51);">调用控制码为</font><strong><font style="color:rgb(51, 51, 51);">SMART_GET_VERSION</font></strong><font style="color:rgb(51, 51, 51);">的</font><font style="color:#DF2A3F;">DeviceIoControl()</font><font style="color:rgb(51, 51, 51);">函数获得输出结构GETVERSIONINPARAMS gvopVersionParams。</font></li>
<li><font style="color:rgb(51, 51, 51);">通过检测gvopVersionParams.bIDEDeviceMap来确定设备类型，并记录在btIDCmd中。</font></li>
<li><font style="color:rgb(51, 51, 51);">填充</font><strong><font style="color:rgb(51, 51, 51);">SENDCMDINPARAMS</font></strong><font style="color:rgb(51, 51, 51);"> inParams参数，注意将第3步得到的btIDCmd赋值给inParams.irDriveRegs.bCommandReg。</font></li>
<li><font style="color:rgb(51, 51, 51);">调用控制码为</font><strong><font style="color:rgb(51, 51, 51);">SMART_RCV_DRIVE_DATA</font></strong><font style="color:rgb(51, 51, 51);">的</font><font style="color:#DF2A3F;">DeviceIoControl()</font><font style="color:rgb(51, 51, 51);">函数，其输入参数为第4步准备好的inParams，得到输出参数outParams。</font></li>
<li><font style="color:rgb(51, 51, 51);">解析outParams-&gt;bBuffer的27~46字节，得到所需的model number。</font></li>
</ol>
<p><font style="color:rgb(51, 51, 51);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">解析outParams-&gt;bBuffer时，因为ATA&#x2F;ATAPI中的WORD与Windows采用的</font><font style="color:#DF2A3F;">字节顺序相反</font><font style="color:rgb(51, 51, 51);">，所以需要</font></p>
<h3 id="将字符串中的字符两两颠倒"><a href="#将字符串中的字符两两颠倒" class="headerlink" title="将字符串中的字符两两颠倒"></a><font style="color:rgb(51, 51, 51);">将字符串中的字符两两颠倒</font></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">CHAR *<span class="hljs-title">ConvertSENDCMDOUTPARAMSBufferToString</span><span class="hljs-params">(<span class="hljs-type">const</span> DWORD *dwDiskData, DWORD nFirstIndex, DWORD nLastIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-type">static</span> CHAR szResBuf[IDENTIFY_BUFFER_SIZE];     <span class="hljs-comment">//512</span><br>       DWORD nIndex = <span class="hljs-number">0</span>;<br>       DWORD nPosition = <span class="hljs-number">0</span>;<br> <br>       <span class="hljs-keyword">for</span> (nIndex = nFirstIndex; nIndex &lt;= nLastIndex; nIndex++)<br>       &#123;<br>        <span class="hljs-comment">// get high byte</span><br>              szResBuf[nPosition] = (CHAR)(dwDiskData[nIndex] &gt;&gt; <span class="hljs-number">8</span>);<br>              nPosition++;<br> <br>              <span class="hljs-comment">// get low byte</span><br>              szResBuf[nPosition] = (CHAR)(dwDiskData[nIndex] &amp; <span class="hljs-number">0xff</span>);<br>              nPosition++;<br>       &#125;<br> <br>       <span class="hljs-comment">// End the string</span><br>       szResBuf[nPosition] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br> <br>       <span class="hljs-keyword">return</span> szResBuf;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Win32-API/" class="category-chain-item">Win32_API</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【NOTE】Windows的磁盘操作</div>
      <div>https://zytpca.github.io/2024/04/10/Win32_Api/【NOTE】Windows的磁盘操作/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Insomniac</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/19/Win32_Api/%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6/" title="使用内存映射文件处理大文件">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">使用内存映射文件处理大文件</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/05/Win32_Api/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8PDH%E8%8E%B7%E5%8F%96CPU%E4%BD%BF%E7%94%A8%E7%8E%87/" title="Windows下使用PDH获取CPU使用率">
                        <span class="hidden-mobile">Windows下使用PDH获取CPU使用率</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"ZDiOGqAWSCAU9bUYDktIk21c-gzGzoHsz","appKey":"JShbv4TgfpvIvvrRl7GFc57n","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zdiogqaw.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
